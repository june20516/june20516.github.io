<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><link rel="stylesheet" href="/_next/static/css/0ad9df217a839d7d.css" data-precedence="next"/><link rel="preload" as="style" href="https://cdn.jsdelivr.net/gh/june20516/orbithall@widget/v1.1.1/static/embed.css"/><link rel="preload" as="script" href="https://www.googletagmanager.com/gtag/js?id=G-Q587R5F0YL"/><link rel="preload" as="script" href="https://cdn.jsdelivr.net/gh/june20516/orbithall@widget/v1.1.1/static/embed.js"/><title>Posts - Bran&#x27;s codeverse</title><meta name="description" content="개발하면서 배운 것들을 기록하고 공유합니다"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="Posts - Bran&#x27;s codeverse"/><meta property="og:description" content="개발하면서 배운 것들을 기록하고 공유합니다"/><meta property="og:site_name" content="Bran&#x27;s codeverse"/><meta property="og:image" content="http://localhost:3000/assets/images/default-thumbnail.jpg"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@codeverse"/><meta name="twitter:title" content="Posts - Bran&#x27;s codeverse"/><meta name="twitter:description" content="개발하면서 배운 것들을 기록하고 공유합니다"/><meta name="twitter:image" content="http://localhost:3000/assets/images/default-thumbnail.jpg"/><link rel="icon" href="/icon.svg?43070ac23468c58b" type="image/svg+xml" sizes="32x32"/><meta name="google-site-verification" content="i0Iq4sKjYlVS7Q9gq9KkCPl4hdoADOzOsTyFnCV24Os"/><style data-emotion="css-global 1mv6lxk">:root{--mui-palette-primary-main:#171717;--mui-palette-secondary-main:#737373;--mui-palette-info-main:#3b82f6;--mui-palette-error-main:#ef4444;--mui-palette-background-default:#ffffff;--mui-palette-action-active:#171717;--mui-palette-action-disabled:#d4d4d4;--mui-palette-text-primary:#171717;--mui-palette-text-secondary:#737373;--mui-palette-text-disabled:#d4d4d4;--mui-palette-divider:#e5e5e5;--mui-typography-fontFamily:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/june20516/orbithall@widget/v1.1.1/static/embed.css"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" noModule=""></script></head><style data-emotion="css k186h9">.css-k186h9{min-height:100vh;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;background-color:#ffffff;}</style><body class="MuiBox-root css-k186h9"><style data-emotion="css 1vseziz">.css-1vseziz{position:-webkit-sticky;position:sticky;top:0;z-index:1000;border-bottom:1px solid #e5e5e5;background-color:#ffffff;overflow:hidden;}.css-1vseziz::before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background-image:url(/assets/images/default-thumbnail.jpg);-webkit-background-size:120%;background-size:120%;-webkit-background-position:center;background-position:center;opacity:1;z-index:0;-webkit-animation:headerBackgroundFloat 300s ease-in-out infinite;animation:headerBackgroundFloat 300s ease-in-out infinite;}@-webkit-keyframes headerBackgroundFloat{0%,100%{-webkit-background-position:center top;background-position:center top;}50%{-webkit-background-position:center bottom;background-position:center bottom;}}@keyframes headerBackgroundFloat{0%,100%{-webkit-background-position:center top;background-position:center top;}50%{-webkit-background-position:center bottom;background-position:center bottom;}}.css-1vseziz::after{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background-color:#ffffff;opacity:0.65;z-index:1;}</style><header class="MuiBox-root css-1vseziz"><style data-emotion="css cam08f">.css-cam08f{position:relative;z-index:2;max-width:1024px;margin-left:auto;margin-right:auto;padding-top:16px;padding-bottom:16px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;gap:32px;}@media (min-width:0px){.css-cam08f{padding-left:24px;padding-right:24px;}}@media (min-width:640px){.css-cam08f{padding-left:32px;padding-right:32px;}}@media (min-width:768px){.css-cam08f{padding-left:48px;padding-right:48px;}}</style><div class="MuiBox-root css-cam08f"><a style="text-decoration:none" href="/"><style data-emotion="css 120nera">.css-120nera{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:12px;}</style><div class="MuiBox-root css-120nera"><svg width="24" height="24" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="32" height="32" rx="6" fill="url(#gradient)"></rect><text x="16" y="22" font-family="system-ui, -apple-system, sans-serif" font-size="18" font-weight="700" fill="white" text-anchor="middle" letter-spacing="-0.02em">B</text><defs><linearGradient id="gradient" x1="0" y1="0" x2="32" y2="32" gradientUnits="userSpaceOnUse"><stop offset="0%" stop-color="#667eea"></stop><stop offset="100%" stop-color="#764ba2"></stop></linearGradient></defs></svg><style data-emotion="css 1bye4no">.css-1bye4no{margin:0;font-size:1.125rem;font-weight:600;line-height:1.5;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#171717;font-weight:600;letter-spacing:-0.01em;-webkit-transition:color 0.2s ease;transition:color 0.2s ease;}.css-1bye4no:hover{color:#737373;}</style><h6 class="MuiTypography-root MuiTypography-h6 css-1bye4no">Codeverse</h6></div></a><style data-emotion="css 1xiah1o">.css-1xiah1o{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}@media (min-width:0px){.css-1xiah1o{gap:16px;}}@media (min-width:640px){.css-1xiah1o{gap:24px;}}</style><nav class="MuiBox-root css-1xiah1o"><a style="text-decoration:none" href="/posts"><style data-emotion="css 4nm0tw">.css-4nm0tw{margin:0;font-size:0.875rem;line-height:1.6;font-weight:400;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#171717;font-weight:500;font-size:0.875rem;-webkit-transition:color 0.2s ease;transition:color 0.2s ease;}.css-4nm0tw:hover{color:#171717;}</style><p class="MuiTypography-root MuiTypography-body2 css-4nm0tw">Posts</p></a><a style="text-decoration:none" href="/tags"><style data-emotion="css 1t5x1u">.css-1t5x1u{margin:0;font-size:0.875rem;line-height:1.6;font-weight:400;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#737373;font-weight:400;font-size:0.875rem;-webkit-transition:color 0.2s ease;transition:color 0.2s ease;}.css-1t5x1u:hover{color:#171717;}</style><p class="MuiTypography-root MuiTypography-body2 css-1t5x1u">Tags</p></a><a style="text-decoration:none" href="/lab"><p class="MuiTypography-root MuiTypography-body2 css-1t5x1u">Lab</p></a><a style="text-decoration:none" href="/about"><p class="MuiTypography-root MuiTypography-body2 css-1t5x1u">About</p></a></nav></div></header><style data-emotion="css 6rhssw">.css-6rhssw{-webkit-flex:1;-ms-flex:1;flex:1;width:100%;max-width:1024px;margin-left:auto;margin-right:auto;padding-top:48px;padding-bottom:48px;}@media (min-width:0px){.css-6rhssw{padding-left:24px;padding-right:24px;}}@media (min-width:640px){.css-6rhssw{padding-left:32px;padding-right:32px;}}@media (min-width:768px){.css-6rhssw{padding-left:48px;padding-right:48px;}}</style><main class="MuiBox-root css-6rhssw"><section style="max-width:720px;margin:0 auto;width:100%"><a style="text-decoration:none" href="posts/scramble-text"><style data-emotion="css 157568j">.css-157568j{padding-top:24px;padding-bottom:24px;border-bottom:1px solid #e5e5e5;-webkit-transition:all 0.2s ease;transition:all 0.2s ease;}.css-157568j:hover{border-bottom-color:#a3a3a3;}.css-157568j:hover .post-title{color:#171717;}</style><div class="MuiBox-root css-157568j"><style data-emotion="css 178uv34">.css-178uv34{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:24px;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;}</style><div class="MuiBox-root css-178uv34"><style data-emotion="css z8l7kn">.css-z8l7kn{border-radius:16px;overflow:hidden;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;background-color:#f5f5f5;}@media (min-width:0px){.css-z8l7kn{width:80px;height:80px;}}@media (min-width:640px){.css-z8l7kn{width:120px;height:120px;}}</style><div class="MuiBox-root css-z8l7kn"><img src="/assets/images/posts/thumbnails/unicode-scramble.png" alt="유니코드 범위를 활용한 텍스트 스크램블 효과 구현하기" style="width:100%;height:100%;object-fit:cover"/></div><style data-emotion="css 1fjtzvx">.css-1fjtzvx{-webkit-flex:1;-ms-flex:1;flex:1;min-width:0;}</style><div class="MuiBox-root css-1fjtzvx"><style data-emotion="css w8q7jp">.css-w8q7jp{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-align-items:baseline;-webkit-box-align:baseline;-ms-flex-align:baseline;align-items:baseline;gap:16px;margin-bottom:8px;}</style><div class="MuiBox-root css-w8q7jp"><style data-emotion="css b0udfb">.css-b0udfb{margin:0;font-size:1.125rem;font-weight:600;line-height:1.5;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#171717;font-weight:500;-webkit-transition:color 0.2s ease;transition:color 0.2s ease;}@media (min-width:0px){.css-b0udfb{font-size:1.0625rem;}}@media (min-width:640px){.css-b0udfb{font-size:1.125rem;}}</style><h6 class="MuiTypography-root MuiTypography-h6 post-title css-b0udfb">유니코드 범위를 활용한 텍스트 스크램블 효과 구현하기</h6><style data-emotion="css 19o4s0j">.css-19o4s0j{margin:0;font-size:0.75rem;line-height:1.5;font-weight:400;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#a3a3a3;white-space:nowrap;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}@media (min-width:0px){.css-19o4s0j{display:none;}}@media (min-width:640px){.css-19o4s0j{display:block;}}</style><span class="MuiTypography-root MuiTypography-caption css-19o4s0j">2026/01/20</span></div><style data-emotion="css 104igq0">.css-104igq0{margin:0;font-size:0.875rem;line-height:1.6;font-weight:400;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#737373;line-height:1.6;}@media (min-width:0px){.css-104igq0{margin-bottom:8px;}}@media (min-width:640px){.css-104igq0{margin-bottom:0px;}}</style><p class="MuiTypography-root MuiTypography-body2 css-104igq0">드르르륵 - 차칵</p><style data-emotion="css sr5pox">.css-sr5pox{margin:0;font-size:0.75rem;line-height:1.5;font-weight:400;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#a3a3a3;}@media (min-width:0px){.css-sr5pox{display:block;}}@media (min-width:640px){.css-sr5pox{display:none;}}</style><span class="MuiTypography-root MuiTypography-caption css-sr5pox">2026/01/20</span></div></div></div></a><a style="text-decoration:none" href="posts/react-native-connect-rpc-migration"><div class="MuiBox-root css-157568j"><div class="MuiBox-root css-178uv34"><div class="MuiBox-root css-z8l7kn"><img src="/assets/images/posts/thumbnails/react-native-connect-rpc-migration.png" alt="React Native에서 REST API를 Connect RPC로 마이그레이션하기" style="width:100%;height:100%;object-fit:cover"/></div><div class="MuiBox-root css-1fjtzvx"><div class="MuiBox-root css-w8q7jp"><h6 class="MuiTypography-root MuiTypography-h6 post-title css-b0udfb">React Native에서 REST API를 Connect RPC로 마이그레이션하기</h6><span class="MuiTypography-root MuiTypography-caption css-19o4s0j">2026/01/05</span></div><p class="MuiTypography-root MuiTypography-body2 css-104igq0">axios를 버리고 타입 안전한 gRPC 세상으로</p><span class="MuiTypography-root MuiTypography-caption css-sr5pox">2026/01/05</span></div></div></div></a><a style="text-decoration:none" href="posts/macos-gui-app-node-path-fix"><div class="MuiBox-root css-157568j"><div class="MuiBox-root css-178uv34"><div class="MuiBox-root css-z8l7kn"><img src="/assets/images/posts/thumbnails/macos-gui-app-node-path-fix.png" alt="macOS GUI 앱에서 nvm Node를 인식하지 못하는 문제 해결하기" style="width:100%;height:100%;object-fit:cover"/></div><div class="MuiBox-root css-1fjtzvx"><div class="MuiBox-root css-w8q7jp"><h6 class="MuiTypography-root MuiTypography-h6 post-title css-b0udfb">macOS GUI 앱에서 nvm Node를 인식하지 못하는 문제 해결하기</h6><span class="MuiTypography-root MuiTypography-caption css-19o4s0j">2025/01/16</span></div><p class="MuiTypography-root MuiTypography-body2 css-104igq0">VS Code 익스텐션이 Node를 찾지 못할 때</p><span class="MuiTypography-root MuiTypography-caption css-sr5pox">2025/01/16</span></div></div></div></a><a style="text-decoration:none" href="posts/finicky-slack-chrome-profile-guide"><div class="MuiBox-root css-157568j"><div class="MuiBox-root css-178uv34"><div class="MuiBox-root css-z8l7kn"><img src="/assets/images/posts/thumbnails/finicky-slack-chrome-profile-guide.png" alt="macOS에서 Slack 링크를 원하는 Chrome 프로필로 열기 (Finicky 사용)" style="width:100%;height:100%;object-fit:cover"/></div><div class="MuiBox-root css-1fjtzvx"><div class="MuiBox-root css-w8q7jp"><h6 class="MuiTypography-root MuiTypography-h6 post-title css-b0udfb">macOS에서 Slack 링크를 원하는 Chrome 프로필로 열기 (Finicky 사용)</h6><span class="MuiTypography-root MuiTypography-caption css-19o4s0j">2024/12/13</span></div><p class="MuiTypography-root MuiTypography-body2 css-104igq0">크롬을 조금 더 스마트하게 써보자</p><span class="MuiTypography-root MuiTypography-caption css-sr5pox">2024/12/13</span></div></div></div></a><a style="text-decoration:none" href="posts/svg-from-scratch"><div class="MuiBox-root css-157568j"><div class="MuiBox-root css-178uv34"><div class="MuiBox-root css-z8l7kn"><img src="/assets/images/posts/thumbnails/svg-from-scratch.png" alt="SVG 그려보기" style="width:100%;height:100%;object-fit:cover"/></div><div class="MuiBox-root css-1fjtzvx"><div class="MuiBox-root css-w8q7jp"><h6 class="MuiTypography-root MuiTypography-h6 post-title css-b0udfb">SVG 그려보기</h6><span class="MuiTypography-root MuiTypography-caption css-19o4s0j">2024/10/1</span></div><span class="MuiTypography-root MuiTypography-caption css-sr5pox">2024/10/1</span></div></div></div></a><a style="text-decoration:none" href="posts/introduce-mermaid"><div class="MuiBox-root css-157568j"><div class="MuiBox-root css-178uv34"><div class="MuiBox-root css-z8l7kn"><img src="/assets/images/posts/thumbnails/mermaid.png" alt="Mermaid - Markdown에서 다이어그램 그리기" style="width:100%;height:100%;object-fit:cover"/></div><div class="MuiBox-root css-1fjtzvx"><div class="MuiBox-root css-w8q7jp"><h6 class="MuiTypography-root MuiTypography-h6 post-title css-b0udfb">Mermaid - Markdown에서 다이어그램 그리기</h6><span class="MuiTypography-root MuiTypography-caption css-19o4s0j">2024/08/1</span></div><span class="MuiTypography-root MuiTypography-caption css-sr5pox">2024/08/1</span></div></div></div></a><a style="text-decoration:none" href="posts/mysql-dockerize-2"><div class="MuiBox-root css-157568j"><div class="MuiBox-root css-178uv34"><div class="MuiBox-root css-z8l7kn"><img src="/assets/images/posts/thumbnails/mysql-dockerize.jpeg" alt="mysql dockerize(2) - mysql container에 볼륨 설정하기" style="width:100%;height:100%;object-fit:cover"/></div><div class="MuiBox-root css-1fjtzvx"><div class="MuiBox-root css-w8q7jp"><h6 class="MuiTypography-root MuiTypography-h6 post-title css-b0udfb">mysql dockerize(2) - mysql container에 볼륨 설정하기</h6><span class="MuiTypography-root MuiTypography-caption css-19o4s0j">2021/11/13</span></div><p class="MuiTypography-root MuiTypography-body2 css-104igq0">로컬 환경을 안전하게 보호하기 위해 MySQL을 도커로 격리하여 실행하는 과정을 기록한다.</p><span class="MuiTypography-root MuiTypography-caption css-sr5pox">2021/11/13</span></div></div></div></a><a style="text-decoration:none" href="posts/mysql-dockerize"><div class="MuiBox-root css-157568j"><div class="MuiBox-root css-178uv34"><div class="MuiBox-root css-z8l7kn"><img src="/assets/images/posts/thumbnails/mysql-dockerize.jpeg" alt="mysql dockerize(1) - 도커로 mysql container 띄우기" style="width:100%;height:100%;object-fit:cover"/></div><div class="MuiBox-root css-1fjtzvx"><div class="MuiBox-root css-w8q7jp"><h6 class="MuiTypography-root MuiTypography-h6 post-title css-b0udfb">mysql dockerize(1) - 도커로 mysql container 띄우기</h6><span class="MuiTypography-root MuiTypography-caption css-19o4s0j">2021/11/07</span></div><p class="MuiTypography-root MuiTypography-body2 css-104igq0">로컬 환경을 안전하게 보호하기 위해 MySQL을 도커로 격리하여 실행하는 과정을 기록한다.</p><span class="MuiTypography-root MuiTypography-caption css-sr5pox">2021/11/07</span></div></div></div></a><a style="text-decoration:none" href="posts/command-tsc-is-not-found"><div class="MuiBox-root css-157568j"><div class="MuiBox-root css-178uv34"><div class="MuiBox-root css-z8l7kn"><img src="/assets/images/posts/thumbnails/command-tsc-is-not-found.png" alt="Command &#x27;tsc&#x27; is not found" style="width:100%;height:100%;object-fit:cover"/></div><div class="MuiBox-root css-1fjtzvx"><div class="MuiBox-root css-w8q7jp"><h6 class="MuiTypography-root MuiTypography-h6 post-title css-b0udfb">Command &#x27;tsc&#x27; is not found</h6><span class="MuiTypography-root MuiTypography-caption css-19o4s0j">2021/10/01</span></div><span class="MuiTypography-root MuiTypography-caption css-sr5pox">2021/10/01</span></div></div></div></a><a style="text-decoration:none" href="posts/rds-dump"><div class="MuiBox-root css-157568j"><div class="MuiBox-root css-178uv34"><div class="MuiBox-root css-z8l7kn"><img src="/assets/images/posts/thumbnails/rds-dump.png" alt="AWS RDS의 Data base를 dump하기" style="width:100%;height:100%;object-fit:cover"/></div><div class="MuiBox-root css-1fjtzvx"><div class="MuiBox-root css-w8q7jp"><h6 class="MuiTypography-root MuiTypography-h6 post-title css-b0udfb">AWS RDS의 Data base를 dump하기</h6><span class="MuiTypography-root MuiTypography-caption css-19o4s0j">2021/09/14</span></div><p class="MuiTypography-root MuiTypography-body2 css-104igq0">VPC 내부에 있는 RDS에서 데이터베이스를 덤프하고, 이를 로컬 MySQL로 복구하는 과정에서 겪은 문제들을 기록한다.</p><span class="MuiTypography-root MuiTypography-caption css-sr5pox">2021/09/14</span></div></div></div></a><a style="text-decoration:none" href="posts/trap-of-htmlcollection"><div class="MuiBox-root css-157568j"><div class="MuiBox-root css-178uv34"><div class="MuiBox-root css-z8l7kn"><img src="/assets/images/posts/thumbnails/trap-of-htmlcollection.jpeg" alt="HTMLCollection의 함정" style="width:100%;height:100%;object-fit:cover"/></div><div class="MuiBox-root css-1fjtzvx"><div class="MuiBox-root css-w8q7jp"><h6 class="MuiTypography-root MuiTypography-h6 post-title css-b0udfb">HTMLCollection의 함정</h6><span class="MuiTypography-root MuiTypography-caption css-19o4s0j">2021/09/07</span></div><p class="MuiTypography-root MuiTypography-body2 css-104igq0">클래스를 기준으로 스크립트를 작성하다가 맞닥트린 예상치 못한 문제</p><span class="MuiTypography-root MuiTypography-caption css-sr5pox">2021/09/07</span></div></div></div></a></section></main><!--$!--><template data-dgst="NEXT_DYNAMIC_NO_SSR_CODE"></template><!--/$--><script src="/_next/static/chunks/webpack-932dee968bc237b7.js" async=""></script><script src="/_next/static/chunks/2443530c-0538301a504b83cf.js" async=""></script><script src="/_next/static/chunks/488-c0b34e96c35b33f7.js" async=""></script><script src="/_next/static/chunks/main-app-98d28d7655df5891.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/0ad9df217a839d7d.css\",{\"as\":\"style\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:I{\"id\":\"8827\",\"chunks\":[\"272:static/chunks/webpack-932dee968bc237b7.js\",\"667:static/chunks/2443530c-0538301a504b83cf.js\",\"488:static/chunks/488-c0b34e96c35b33f7.js\"],\"name\":\"\",\"async\":false}\n5:I{\"id\":\"9126\",\"chunks\":[\"272:static/chunks/webpack-932dee968bc237b7.js\",\"667:static/chunks/2443530c-0538301a504b83cf.js\",\"488:static/chunks/488-c0b34e96c35b33f7.js\"],\"name\":\"\",\"async\":false}\n6:I{\"id\":\"6886\",\"chunks\":[\"771:static/chunks/771-437baa63a3bc2c51.js\",\"846:static/chunks/846-5374114718c3ba3f.js\",\"218:static/"])</script><script>self.__next_f.push([1,"chunks/218-24e2ed3a86df3181.js\",\"185:static/chunks/app/layout-1a9b501ae2e54936.js\"],\"name\":\"\",\"async\":false}\n8:I{\"id\":\"4463\",\"chunks\":[\"272:static/chunks/webpack-932dee968bc237b7.js\",\"667:static/chunks/2443530c-0538301a504b83cf.js\",\"488:static/chunks/488-c0b34e96c35b33f7.js\"],\"name\":\"\",\"async\":false}\n9:I{\"id\":\"1010\",\"chunks\":[\"272:static/chunks/webpack-932dee968bc237b7.js\",\"667:static/chunks/2443530c-0538301a504b83cf.js\",\"488:static/chunks/488-c0b34e96c35b33f7.js\"],\"name\":\"\",\"async\":false}\na:I{\"id\":\"6640\",\""])</script><script>self.__next_f.push([1,"chunks\":[\"771:static/chunks/771-437baa63a3bc2c51.js\",\"846:static/chunks/846-5374114718c3ba3f.js\",\"605:static/chunks/app/tags/[tag]/page-22609de8da84a426.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ad9df217a839d7d.css\",\"precedence\":\"next\"}]],[\"$\",\"$L3\",null,{\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/posts\",\"initialTree\":[\"\",{\"children\":[\"posts\",{\"children\":[\"__PAGE__\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[\"$L4\",null],\"globalErrorComponent\":\"$5\",\"notFound\":[\"$\",\"$L6\",null,{\"params\":{},\"children\":[\"$L7\",\"$undefined\",[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]]}],\"asNotFound\":false,\"children\":[[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[[\"$\",\"section\",null,{\"style\":{\"maxWidth\":\"720px\",\"margin\":\"0 auto\",\"width\":\"100%\"},\"children\":[[\"$\",\"$La\",\"0\",{\"post\":{\"slug\":\"scramble-text\",\"meta\":{\"title\":\"유니코드 범위를 활용한 텍스트 스크램블 효과 구현하기\",\"description\":\"드르르륵 - 차칵\",\"date\":\"2026/01/20\",\"tags\":[\"typescript\",\"components\",\"react\",\"animation\",\"ui\"],\"thumbnail\":\"assets/images/posts/thumbnails/unicode-scramble.png\"},\"content\":\"\\n# [React] 유니코드 범위를 활용한 텍스트 스크램블 효과 구현하기\\n\\n정적인 텍스트에 생동감을 불어넣기 위해, 글자가 암호를 해독하듯 빠르게 변화하며 완성되는 '스크램블(Scramble)' 효과를 구현해 보았다. 단순히 무작위 문자를 보여주는 것이 아니라, 문자가 속한 유니코드 범위 내에서 값이 점진적으로 변하도록 하여 시각적인 개연성을 부여하는 것이 목표다.\\n\\n\u003e Demo\\n\\n이 포스트에서 다루는 컴포넌트의 실제 동작 모습은 [lab/scramble-text](/lab/scramble-text) 페이지에서 직접 확인해 볼 수 있다.\\n\\n전체 컴포넌트의 코드는 포스트의 끝에 첨부한다.\\n\\n## 원리와 의도\\n\\n이 컴포넌트의 핵심 원리는 문자(Character)를 숫자(Code Point)로 치환하여 다루는 것이다.\\n\\n컴퓨터 내부에서 모든 문자는 고유한 숫자를 가진다. 예를 들어 'A'는 65, 'B'는 66이다. 우리가 목표로 하는 글자가 'Z'(90)라면, 65부터 90까지 숫자를 빠르게 증가시키며 문자로 변환해 보여줌으로써 마치 슬롯머신이 돌아가는 듯한 효과를 줄 수 있다.\\n\\n이때 중요한 점은 **'문맥에 맞는 범위'**를 설정하는 것이다. 한글이 나와야 할 자리에서 뜬금없이 특수문자나 알파벳이 나오면 어색하다. 따라서 문자의 종류(숫자, 영문 대소문자, 한글 등)를 식별하고, 해당 범위의 시작점(Start Code)에서 목표 문자(Target Code)까지 도달하는 경로(Track)를 생성하여 자연스러운 연출을 의도했다.\\n\\n## 컴포넌트 구조\\n\\n구현된 ScrambleText 컴포넌트는 크게 세 가지 단계로 동작한다.\\n\\n범위 탐색 (findCharRange): 입력된 문자가 어느 유니코드 블록(예: 한글 소리마디, 영문 대문자 등)에 속하는지 판별한다.\\n\\n트랙 생성 (createScrambleTrack): 해당 블록의 시작 코드부터 목표 코드까지의 숫자 배열을 생성한다. 이때 maxSteps를 기준으로 중간 과정을 생략하거나 촘촘하게 채워 애니메이션 길이를 조절한다.\\n\\n애니메이션 실행 (animate): setTimeout을 재귀적으로 호출하며 트랙의 숫자를 순차적으로 문자로 변환해 렌더링한다.\\n\\n## 주요 구현 코드\\n\\n### 1. 유니코드 범위 정의\\n\\n자주 사용되는 문자의 범위를 튜플로 정의해 두었다. 특히 한글은 '가'부터 '힣'까지의 완성형 범위(44032~55203)를 사용하여, 자모음이 분리되지 않고 온전한 글자 형태로 변화하도록 했다.\\n\\n```TypeScript\\n\\nconst CHARACTER_RANGES: CodeRange[] = [\\n[48, 57], // 0-9\\n[65, 90], // A-Z\\n[97, 122], // a-z\\n[44032, 55203], // 가-힣\\n// ... (기타 특수문자 및 자모 범위)\\n];\\n```\\n\\n### 2. 속도 조절 (Ease-out 효과)\\n\\n모든 글자가 똑같은 속도로 멈추면 기계적인 느낌이 강하다. 이를 완화하기 위해 마지막 글자가 완성되기 직전(layback 구간)에는 딜레이를 지수적으로 증가시키는 calculateSlowdownInterval 함수를 적용했다. 덕분에 글자가 '철컥'하고 맞물리는 듯한 타건감을 줄 수 있다.\\n\\n```TypeScript\\nconst calculateSlowdownInterval = (\\nbaseInterval: number,\\nremaining: number,\\nlayback: number,\\n): number =\u003e {\\nif (remaining \u003e= layback) return baseInterval;\\n// 남은 단계가 적을수록 간격을 넓혀 속도를 줄인다\\nreturn baseInterval \\\\* Math.pow(1.5, layback - remaining);\\n};\\n```\\n\\n### 3. 렌더링 최적화\\n\\nReact의 useState로 화면에 표시될 문자 배열(displayChars)을 관리하고, useEffect 내에서 애니메이션 로직을 수행한다. requestAnimationFrame 대신 setTimeout을 사용한 이유는 각 글자마다 미세하게 다른 속도(Ease-out)를 개별적으로 제어하기 위함이다.\\n\\n## 주의 사항\\n\\n구현 시 몇 가지 고려해야 할 점들이 있다.\\n\\n- 메모리 누수 방지: 컴포넌트가 애니메이션 도중 언마운트될 경우를 대비해 cleanup 함수에서 반드시 clearTimeout을 호출해야 한다. 위 코드에서는 isAnimatingRef 플래그와 클로저 변수 timerId를 통해 이를 관리하고 있다.\\n\\n- 유니코드 범위 예외 처리: 정의되지 않은 범위의 문자(예: 이모지, 희귀 외국어)가 들어올 경우 CHARACTER_RANGES.find가 실패할 수 있다. 이에 대비해 기본값(SPACE_CODE)을 반환하거나, 해당 문자는 애니메이션 없이 바로 보여주는 식의 처리가 필요하다.\\n\\n- 성능: 문자열이 매우 길어지면 각 문자마다 setTimeout이 돌기 때문에 성능 저하가 발생할 수 있다. 긴 텍스트의 경우 maxSteps를 줄이거나, 화면에 보이는 부분만 애니메이션 처리하는 최적화가 필요할 수 있다.\\n\\n## 정리\\n\\n이 컴포넌트는 단순히 화려함을 더하는 것을 넘어, 데이터가 로딩되거나 값이 변화할 때 사용자에게 시각적인 피드백을 주는 용도로 활용하기 좋다. 유니코드라는 문자의 본질적인 속성을 활용했기 때문에, 별도의 라이브러리 없이도 꽤 그럴싸한 효과를 낼 수 있었다.\\n\\n---\\n\\n\u003cdetails\u003e\\n\u003csummary\u003e컴포넌트 코드\u003c/summary\u003e\\n\\n```typescript\\nimport { Typography } from '@mui/material';\\nimport { useCallback, useEffect, useRef, useState } from 'react';\\n\\ntype CodeRange = readonly [number, number];\\n\\nconst SPACE_CODE = 32;\\n\\nconst CHARACTER_RANGES: CodeRange[] = [\\n  [48, 57], // 0-9\\n  [65, 90], // A-Z\\n  [97, 122], // a-z\\n  [44032, 55203], // 가-힣\\n  [12593, 12622], // ㄱ-ㅎ\\n  [12623, 12643], // ㅏ-ㅣ\\n  [33, 47], // !\\\"#$%\u0026'()*+,-./\\n  [58, 64], // :;\u003c=\u003e?@\\n  [91, 96], // [\\\\]^_`\\n  [123, 126], // {|}~\\n  [SPACE_CODE, SPACE_CODE],\\n];\\n\\nconst findCharRange = (char: string): CodeRange =\u003e {\\n  const code = char.codePointAt(0) ?? SPACE_CODE;\\n  return (\\n    CHARACTER_RANGES.find(([start, end]) =\u003e code \u003e= start \u0026\u0026 code \u003c= end) ?? [\\n      SPACE_CODE,\\n      SPACE_CODE,\\n    ]\\n  );\\n};\\n\\ninterface ScrambleTrack {\\n  codes: number[];\\n  length: number;\\n}\\n\\nconst createScrambleTrack = (char: string, maxSteps: number): ScrambleTrack =\u003e {\\n  if (char === ' ') {\\n    return { codes: [], length: 0 };\\n  }\\n\\n  const [rangeStart] = findCharRange(char);\\n  const targetCode = char.codePointAt(0) ?? SPACE_CODE;\\n  const distance = targetCode - rangeStart;\\n  const step = Math.max(1, Math.floor(distance / maxSteps));\\n\\n  const codes: number[] = [];\\n  for (let code = rangeStart; code \u003c targetCode; code += step) {\\n    codes.push(code);\\n  }\\n  codes.push(targetCode);\\n\\n  return { codes, length: codes.length };\\n};\\n\\nconst updateCharAt = (chars: string[], index: number, newChar: string): string[] =\u003e {\\n  const next = [...chars];\\n  next[index] = newChar;\\n  return next;\\n};\\n\\nconst calculateSlowdownInterval = (\\n  baseInterval: number,\\n  remaining: number,\\n  layback: number,\\n): number =\u003e {\\n  if (remaining \u003e= layback) return baseInterval;\\n  const slowdownFactor = layback - remaining;\\n  return baseInterval * Math.pow(1.5, slowdownFactor);\\n};\\n\\ninterface ScrambleTextProps {\\n  value: string;\\n  maxSteps?: number;\\n  layback?: number;\\n  baseInterval?: number;\\n}\\n\\nconst ScrambleText = ({\\n  value,\\n  maxSteps = 20,\\n  layback = 7,\\n  baseInterval = 30,\\n}: ScrambleTextProps) =\u003e {\\n  const [displayChars, setDisplayChars] = useState\u003cstring[]\u003e(() =\u003e Array(value.length).fill(' '));\\n  const isAnimatingRef = useRef(false);\\n\\n  const createTrackForValue = useCallback(\\n    () =\u003e Array.from(value).map(char =\u003e createScrambleTrack(char, maxSteps)),\\n    [value, maxSteps],\\n  );\\n\\n  useEffect(() =\u003e {\\n    if (value.length === 0) return;\\n\\n    setDisplayChars(Array(value.length).fill(' '));\\n    isAnimatingRef.current = true;\\n    const tracks = createTrackForValue();\\n\\n    let charIndex = 0;\\n    let codeIndex = 0;\\n    let timerId: ReturnType\u003ctypeof setTimeout\u003e | null = null;\\n\\n    const animate = () =\u003e {\\n      if (charIndex \u003e= value.length) {\\n        isAnimatingRef.current = false;\\n        return;\\n      }\\n\\n      const track = tracks[charIndex];\\n      const isTrackComplete = !track.codes.length || codeIndex \u003e= track.length;\\n\\n      if (isTrackComplete) {\\n        setDisplayChars(prev =\u003e updateCharAt(prev, charIndex, value[charIndex]));\\n        charIndex++;\\n        codeIndex = 0;\\n        timerId = setTimeout(animate, baseInterval);\\n        return;\\n      }\\n\\n      const currentCode = track.codes[codeIndex];\\n      setDisplayChars(prev =\u003e updateCharAt(prev, charIndex, String.fromCodePoint(currentCode)));\\n      codeIndex++;\\n\\n      const isLastChar = charIndex === value.length - 1;\\n      const remaining = track.length - codeIndex;\\n      const interval = isLastChar\\n        ? calculateSlowdownInterval(baseInterval, remaining, layback)\\n        : baseInterval;\\n\\n      timerId = setTimeout(animate, interval);\\n    };\\n\\n    animate();\\n\\n    return () =\u003e {\\n      if (timerId) clearTimeout(timerId);\\n      isAnimatingRef.current = false;\\n    };\\n  }, [value, createTrackForValue, layback, baseInterval]);\\n\\n  return (\\n    \u003cTypography variant=\\\"h1\\\" sx={{ padding: 10 }}\u003e\\n      {displayChars.join('')}\\n    \u003c/Typography\u003e\\n  );\\n};\\n\\nexport default ScrambleText;\\n```\\n\\n\u003c/details\u003e\\n\"}}],[\"$\",\"$La\",\"1\",{\"post\":{\"slug\":\"react-native-connect-rpc-migration\",\"meta\":{\"title\":\"React Native에서 REST API를 Connect RPC로 마이그레이션하기\",\"description\":\"axios를 버리고 타입 안전한 gRPC 세상으로\",\"date\":\"2026/01/05\",\"tags\":[\"React Native\",\"Connect RPC\",\"Protobuf\",\"gRPC\",\"typescript\"],\"categories\":[\"dev\",\"architecture\"],\"thumbnail\":\"assets/images/posts/thumbnails/react-native-connect-rpc-migration.png\"},\"content\":\"\\n# React Native에서 REST API를 Connect RPC로 마이그레이션하기\\n\\nAPI 문서의 중요함은 웹 개발자들 사이에서 말하면 입아플 정도로 널리 공감되는 주제이다. 이를 위해 많은 도구들이 존재하고 다양한 노력들이 이루어졌다.\\n나는 최근에 프로젝트를 진행하며 백엔드 입장에서 문서를 제공해야 했었고, 가져가기로 한 기술 스택에서 이 문서화 도구의 지원이 빈약함을 알게 되었다. 그래서 조금 더 많은 수작업이 필요해졌는데, 갑자기 회의감이 들었다. 코드와 코드의 대화 사이에 들어가는 사람의 손길, 이 헐거움이 어색하게 느껴졌다.\\n이 문제를 근본적으로 해결하기 위해 REST API를 버리고 [Connect RPC](https://connectrpc.com/)로 전환하기로 결정했다. Connect RPC는 [gRPC](https://grpc.io/)의 장점(타입 안전성, 코드 생성)을 가져오면서도 HTTP/1.1을 지원해 React Native에서도 사용할 수 있다.\\n\\n## 왜 Connect RPC인가?\\n\\n### REST API의 문제점\\n\\n기존에는 [axios](https://axios-http.com/)로 REST API를 호출하고, 응답 타입을 수동으로 정의했다.\\n\\n```typescript\\n// 수동으로 작성한 타입\\ninterface ProfileResponse {\\n  profile: {\\n    userId: number;\\n    nickname: string;\\n    // ... 30개 이상의 필드\\n  };\\n}\\n\\n// API 호출\\nconst response = await axios.get\u003cProfileResponse\u003e('/profiles/me');\\n```\\n\\n이 방식은 종종 이런 문제를 야기할 수 있다.\\n\\n1. **(그럴 일은 절대 없어야 하지만)백엔드가 API를 일방적으로 변경하면 프론트엔드는 런타임 에러가 나서야 안다**\\n2. **타입 정의가 실제 API와 달라져도 TypeScript는 모른다**\\n3. **필드 하나 추가될 때마다 타입 정의를 찾아서 수정해야 한다**\\n\\n### Connect RPC의 장점\\n\\nConnect RPC는 [Protobuf](https://protobuf.dev/) 스키마를 공유하고 코드를 자동 생성한다.\\n\\n```protobuf\\n// proto 파일 (백엔드와 공유)\\nmessage Profile {\\n  int64 user_id = 1;\\n  optional string nickname = 2;\\n  // ...\\n}\\n\\nservice ProfileService {\\n  rpc GetMyProfile(GetMyProfileRequest) returns (GetMyProfileResponse);\\n}\\n```\\n\\n이 스키마에서 TypeScript 타입과 클라이언트 코드가 자동 생성되므로 아래와 같은 효과를 볼 수 있다.\\n\\n1. **백엔드가 스키마를 바꾸면 프론트엔드의 타입이 컴파일 타임에 깨진다**\\n2. **타입 정의가 항상 실제 API와 일치한다**\\n3. **proto 파일만 받으면 코드 생성으로 모든 게 업데이트된다**\\n\\n## 1. Protobuf Repository 추가\\n\\n백엔드와 proto 파일을 공유하기 위해 별도 저장소를 만들고 [git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules)로 관리하기로 했다.\\n\\n```bash\\n# proto repository를 submodule로 추가\\ngit submodule add git@github.com:your-org/myapp-proto.git proto\\n\\n# 폴더 구조\\nproto/\\n  ├── myapp/\\n  │   └── v1/\\n  │       ├── auth.proto\\n  │       ├── profile.proto\\n  │       └── interest.proto\\n  └── buf.yaml\\n```\\n\\nproto 파일 예시\\n\\n```protobuf\\n// myapp/v1/auth.proto\\nsyntax = \\\"proto3\\\";\\n\\npackage myapp.v1;\\n\\nservice AuthService {\\n  rpc RequestSignup(RequestSignupRequest) returns (RequestSignupResponse);\\n  rpc VerifySignup(VerifySignupRequest) returns (VerifySignupResponse);\\n  rpc GetMe(GetMeRequest) returns (GetMeResponse);\\n}\\n\\nmessage RequestSignupRequest {\\n  string email = 1;\\n}\\n\\nmessage RequestSignupResponse {\\n  string message = 1;\\n}\\n\\nmessage VerifySignupRequest {\\n  string email = 1;\\n  string code = 2;\\n}\\n\\nmessage VerifySignupResponse {\\n  string access_token = 1;\\n  string refresh_token = 2;\\n}\\n```\\n\\n## 2. 패키지 설치\\n\\nConnect RPC와 Protobuf 관련 패키지를 설치한다.\\n\\n```bash\\n# 런타임 라이브러리\\nyarn add @connectrpc/connect @connectrpc/connect-web @bufbuild/protobuf\\n\\n# 코드 생성 도구 (dev dependencies)\\nyarn add -D @bufbuild/buf @bufbuild/protoc-gen-es @connectrpc/protoc-gen-connect-es\\n```\\n\\n각 패키지의 역할\\n\\n- `@connectrpc/connect`: Connect RPC 핵심 라이브러리\\n- `@connectrpc/connect-web`: HTTP/1.1 기반 transport (React Native 호환)\\n- `@bufbuild/protobuf`: Protobuf 메시지 런타임\\n- [`@bufbuild/buf`](https://buf.build/docs/introduction): 코드 생성 CLI\\n- `@bufbuild/protoc-gen-es`: TypeScript 타입 생성 플러그인\\n- `@connectrpc/protoc-gen-connect-es`: Connect 서비스 클라이언트 생성 플러그인\\n\\n## 3. buf 설정 및 코드 생성\\n\\n`buf.gen.yaml` 파일을 만들어 코드 생성 설정을 작성한다.\\n\\n```yaml\\n# buf.gen.yaml\\nversion: v2\\ninputs:\\n  - directory: proto\\nplugins:\\n  - local: protoc-gen-es\\n    out: gen\\n    opt:\\n      - target=ts\\n  - local: protoc-gen-connect-es\\n    out: gen\\n    opt:\\n      - target=ts\\n```\\n\\npackage.json에 코드 생성 스크립트를 추가한다.\\n\\n```json\\n{\\n  \\\"scripts\\\": {\\n    \\\"generate\\\": \\\"buf generate\\\"\\n  }\\n}\\n```\\n\\n코드를 생성한다.\\n\\n```bash\\nyarn generate\\n```\\n\\n이제 `gen/` 폴더에 TypeScript 코드가 자동 생성된다.\\n\\n```\\ngen/\\n  └── myapp/\\n      └── v1/\\n          ├── auth_pb.ts        # 메시지 타입\\n          ├── auth_connect.ts   # 서비스 정의\\n          ├── profile_pb.ts\\n          ├── profile_connect.ts\\n          └── ...\\n```\\n\\n생성된 코드 예시\\n\\n```typescript\\n// gen/myapp/v1/auth_pb.ts\\nexport type VerifySignupRequest = Message\u003c'myapp.v1.VerifySignupRequest'\u003e \u0026 {\\n  email: string;\\n  code: string;\\n};\\n\\nexport type VerifySignupResponse = Message\u003c'myapp.v1.VerifySignupResponse'\u003e \u0026 {\\n  accessToken: string;\\n  refreshToken: string;\\n};\\n```\\n\\n## 4. Metro 설정 (중요!)\\n\\nReact Native의 [Metro bundler](https://metrobundler.dev/)가 Connect 패키지의 [package exports](https://nodejs.org/api/packages.html#exports)를 인식하도록 설정해야 한다. 이 설정이 없으면 런타임 에러가 발생한다.\\n\\n```javascript\\n// metro.config.js\\nconst { getDefaultConfig } = require('expo/metro-config');\\n\\nconst config = getDefaultConfig(__dirname);\\n\\n// package exports 활성화 (필수!)\\nconfig.resolver.unstable_enablePackageExports = true;\\n\\nmodule.exports = config;\\n```\\n\\nConnect 패키지는 Node.js 스타일의 package exports를 사용하는데, React Native의 Metro bundler는 기본적으로 이를 지원하지 않기 때문이다.\\n\\n## 5. Transport 및 클라이언트 설정\\n\\nConnect 클라이언트를 설정한다.\\n\\n```typescript\\n// api/transport.ts\\nimport { createClient } from '@connectrpc/connect';\\nimport { createConnectTransport } from '@connectrpc/connect-web';\\n\\nimport { AuthService } from '@/gen/myapp/v1/auth_pb';\\nimport { ProfileService } from '@/gen/myapp/v1/profile_pb';\\nimport { InterestService } from '@/gen/myapp/v1/interest_pb';\\n\\nimport { createAuthInterceptor, createLoggingInterceptor } from './interceptors';\\n\\nconst API_URL = process.env.EXPO_PUBLIC_SERVER_URL;\\n\\nif (!API_URL) {\\n  throw new Error('EXPO_PUBLIC_SERVER_URL is not defined');\\n}\\n\\nconst transport = createConnectTransport({\\n  baseUrl: API_URL,\\n  interceptors: [createLoggingInterceptor(), createAuthInterceptor()],\\n});\\n\\nexport const authClient = createClient(AuthService, transport);\\nexport const profileClient = createClient(ProfileService, transport);\\nexport const interestClient = createClient(InterestService, transport);\\n```\\n\\n## 6. 인터셉터 구현\\n\\n인증 토큰 주입과 에러 핸들링을 위한 인터셉터를 구현한다.\\n\\n```typescript\\n// api/interceptors.ts\\nimport type { Interceptor } from '@connectrpc/connect';\\n\\nimport { useAuthStore } from '@/stores/authStore';\\n\\nexport const createAuthInterceptor = (): Interceptor =\u003e next =\u003e async req =\u003e {\\n  const token = useAuthStore.getState().accessToken;\\n\\n  if (token) {\\n    req.header.set('Authorization', `Bearer ${token}`);\\n  }\\n\\n  return await next(req);\\n};\\n\\nexport const createLoggingInterceptor = (): Interceptor =\u003e next =\u003e async req =\u003e {\\n  console.log(`[Connect] ${req.method.name}`, req.message);\\n\\n  const response = await next(req);\\n\\n  console.log(`[Connect] ${req.method.name} response`, response.message);\\n\\n  return response;\\n};\\n```\\n\\nConnect의 인터셉터는 axios의 인터셉터와 비슷하지만 더 type-safe하다. 요청과 응답에 대한 모든 정보가 타입으로 보장된다.\\n\\n## 7. 에러 핸들링\\n\\nConnect RPC에서는 두 가지 에러 처리 방식이 있다.\\n\\n1. **Network/Protocol 에러** - Connect의 기본 `ConnectError` (네트워크 장애, 인증 실패 등)\\n2. **비즈니스 로직 에러** - Protobuf로 정의된 `Error` 메시지\\n\\n먼저 proto에 Error 메시지를 정의한다.\\n\\n```protobuf\\n// proto/myapp/v1/common.proto\\nmessage Error {\\n  ErrorCode code = 1;\\n  string message = 2;\\n  map\u003cstring, string\u003e details = 3;\\n}\\n\\nenum ErrorCode {\\n  ERROR_CODE_UNSPECIFIED = 0;\\n  ERROR_CODE_PROFILE_NOT_FOUND = 1;\\n  ERROR_CODE_AUTH_ERROR = 2;\\n  ERROR_CODE_INVALID_TOKEN = 3;\\n  // ...\\n}\\n```\\n\\n모든 응답은 `oneof result` 패턴을 사용한다.\\n\\n```protobuf\\nmessage VerifySignupResponse {\\n  oneof result {\\n    VerifySignupSuccess success = 1;\\n    Error error = 2;\\n  }\\n}\\n\\nmessage VerifySignupSuccess {\\n  string access_token = 1;\\n  string refresh_token = 2;\\n}\\n```\\n\\n이 패턴을 처리하기 위해 `unwrap()` 함수와 `ApplicationError` 클래스를 만든다.\\n\\n```typescript\\n// api/connectError.ts\\nimport { ConnectError } from '@connectrpc/connect';\\n\\nimport { Error as ProtoError, ErrorCode } from '@/gen/myapp/v1/common_pb';\\n\\n/**\\n * 비즈니스 로직 에러\\n * Proto에 정의된 Error 메시지를 래핑함\\n */\\nexport class ApplicationError extends Error {\\n  code: ErrorCode;\\n  details: { [key: string]: string };\\n\\n  constructor(code: ErrorCode, message: string, details: { [key: string]: string } = {}) {\\n    super(message);\\n    this.code = code;\\n    this.details = details;\\n    Object.setPrototypeOf(this, ApplicationError.prototype);\\n  }\\n\\n  static fromProto(error: ProtoError): ApplicationError {\\n    return new ApplicationError(error.code, error.message, error.details);\\n  }\\n}\\n\\n/**\\n * oneof result에서 성공값을 추출하거나 에러를 throw\\n */\\nexport function unwrap\u003cT\u003e(response: {\\n  result:\\n    | { case: 'success'; value: T }\\n    | { case: 'error'; value: ProtoError }\\n    | { case: undefined };\\n}): NonNullable\u003cT\u003e {\\n  if (response.result.case === 'error') {\\n    throw ApplicationError.fromProto(response.result.value);\\n  }\\n  if (response.result.case === 'success') {\\n    return response.result.value as NonNullable\u003cT\u003e;\\n  }\\n  throw new ApplicationError(ErrorCode.INTERNAL, 'Unknown response result');\\n}\\n\\n/**\\n * ConnectError를 ApplicationError로 변환\\n */\\nexport const handleConnectError = (error: unknown): ApplicationError =\u003e {\\n  if (error instanceof ApplicationError) {\\n    return error;\\n  }\\n\\n  if (error instanceof ConnectError) {\\n    // 네트워크 에러 등을 SYSTEM_ERROR로 매핑\\n    return new ApplicationError(ErrorCode.SYSTEM_ERROR, error.message);\\n  }\\n\\n  if (error instanceof Error) {\\n    return new ApplicationError(\\n      ErrorCode.INTERNAL,\\n      error.message || '알 수 없는 오류가 발생했습니다',\\n    );\\n  }\\n\\n  return new ApplicationError(ErrorCode.UNSPECIFIED, '알 수 없는 오류가 발생했습니다');\\n};\\n```\\n\\n### 백엔드 구현\\n\\n백엔드는 비즈니스 로직 에러를 Protobuf `Error` 메시지로 만든다. 이 방식을 사용하면 에러 코드가 proto enum으로 정의되어 백엔드-프론트엔드 간 타입 일치가 보장된다.\\n\\n```go\\n// internal/response/errors.go\\nfunc NewConnectError(code domain.ErrorCode, err error) *connect.Error {\\n  connectErr := connect.NewError(toConnectCode(code), err)\\n\\n  // Protobuf Error 메시지 생성\\n  protoErr := \u0026duologuev1.Error{\\n    Code:    domain.ToProtoErrorCode(code),\\n    Message: err.Error(),\\n    Details: make(map[string]string),\\n  }\\n\\n  // Error를 Connect error detail로 추가\\n  if detail, detailErr := connect.NewErrorDetail(protoErr); detailErr == nil {\\n    connectErr.AddDetail(detail)\\n  }\\n\\n  return connectErr\\n}\\n```\\n\\n### 인터셉터에서 에러 코드별 처리\\n\\n인터셉터에서 특정 에러 코드에 대한 공통 처리를 할 수 있다.\\n\\n```typescript\\n// api/interceptors.ts\\nexport const createAuthInterceptor = (): Interceptor =\u003e next =\u003e async req =\u003e {\\n  const token = useAuthStore.getState().accessToken;\\n  if (token) {\\n    req.header.set('Authorization', `Bearer ${token}`);\\n  }\\n\\n  try {\\n    return await next(req);\\n  } catch (error) {\\n    if (error instanceof ApplicationError) {\\n      // 프로필 없음 → 로그아웃 처리\\n      if (error.code === ErrorCode.PROFILE_NOT_FOUND) {\\n        useAuthStore.getState().clearAuth();\\n        router.replace('/');\\n        throw error;\\n      }\\n\\n      // 인증 에러 → 토큰 갱신 시도\\n      if (\\n        error.code === ErrorCode.AUTH_ERROR ||\\n        error.code === ErrorCode.AUTH_REQUIRED ||\\n        error.code === ErrorCode.INVALID_TOKEN\\n      ) {\\n        const newToken = await tokenRefreshManager.refresh();\\n        req.header.set('Authorization', `Bearer ${newToken}`);\\n        return await next(req); // 재시도\\n      }\\n    }\\n\\n    throw error;\\n  }\\n};\\n```\\n\\n이렇게 함으로써 이제 에러를 보다 편하게 다룰 수 있다.\\n\\n1. **타입 안전한 에러 처리** - ErrorCode enum으로 가능한 에러를 컴파일 타임에 알 수 있음\\n2. **중앙화된 에러 처리** - 인터셉터에서 공통 에러 로직 처리\\n3. **명시적인 에러 흐름** - oneof를 통해 성공/실패가 proto 레벨에서 명확히 구분됨\\n\\n## 8. API 레이어 마이그레이션\\n\\n이제 기존 axios 기반 API를 Connect로 교체한다.\\n\\n### Before (axios)\\n\\n```typescript\\n// api/auth.ts (before)\\nimport { apiClient } from './client';\\n\\ninterface VerifySignupRequest {\\n  email: string;\\n  code: string;\\n}\\n\\ninterface TokenResponse {\\n  access_token: string;\\n  refresh_token: string;\\n}\\n\\nexport const authApi = {\\n  verifySignup: async (email: string, code: string): Promise\u003cTokenResponse\u003e =\u003e {\\n    const response = await apiClient.post\u003cTokenResponse\u003e('/auth/verify-signup', {\\n      email,\\n      code,\\n    });\\n    return response.data;\\n  },\\n};\\n```\\n\\n### After (Connect)\\n\\n```typescript\\n// api/auth.ts (after)\\nimport { create } from '@bufbuild/protobuf';\\n\\nimport { VerifySignupRequestSchema } from '@/gen/myapp/v1/auth_pb';\\n\\nimport { handleConnectError } from './connectError';\\nimport { authClient } from './transport';\\n\\ninterface TokenResponse {\\n  accessToken: string;\\n  refreshToken: string;\\n}\\n\\nexport const authApi = {\\n  verifySignup: async (email: string, code: string): Promise\u003cTokenResponse\u003e =\u003e {\\n    try {\\n      const request = create(VerifySignupRequestSchema, { email, code });\\n      const response = await authClient.verifySignup(request);\\n      const result = unwrap(response); // oneof result 처리\\n      return {\\n        accessToken: result.accessToken,\\n        refreshToken: result.refreshToken,\\n      };\\n    } catch (error) {\\n      throw handleConnectError(error);\\n    }\\n  },\\n};\\n```\\n\\n변경된 점은 다음과 같다.\\n\\n1. **타입을 수동으로 정의하지 않는다** - proto에서 자동 생성됨\\n2. **URL 경로를 하드코딩하지 않는다** - 서비스 정의에 포함됨\\n3. **create()로 요청 메시지를 생성한다** - 타입 안전성 보장\\n\\n### Profile API 예시\\n\\n```typescript\\n// api/profile.ts\\nimport { create } from '@bufbuild/protobuf';\\n\\nimport { GetMyProfileRequestSchema, UpdateMyProfileRequestSchema } from '@/gen/myapp/v1/profile_pb';\\n\\nimport { handleConnectError } from './connectError';\\nimport { profileClient } from './transport';\\n\\nexport const profileApi = {\\n  getMe: async (): Promise\u003cProfileMe\u003e =\u003e {\\n    try {\\n      const request = create(GetMyProfileRequestSchema, {});\\n      const response = await profileClient.getMyProfile(request);\\n      const result = unwrap(response); // oneof result 처리\\n\\n      return mapProfile(result.profile);\\n    } catch (error) {\\n      throw handleConnectError(error);\\n    }\\n  },\\n\\n  updateMe: async (data: UpdateProfileData): Promise\u003cProfileMe\u003e =\u003e {\\n    try {\\n      const request = create(UpdateMyProfileRequestSchema, {\\n        nickname: data.nickname,\\n        gender: data.gender,\\n        region: data.region,\\n        shortBio: data.shortBio,\\n        profileImageUrl: data.profileImageUrl,\\n        interestIds: data.interestIds?.map(id =\u003e BigInt(id)) ?? [],\\n      });\\n\\n      const response = await profileClient.updateMyProfile(request);\\n      const result = unwrap(response); // oneof result 처리\\n\\n      return mapProfile(result.profile);\\n    } catch (error) {\\n      throw handleConnectError(error);\\n    }\\n  },\\n};\\n```\\n\\n## 9. React Query 훅은 그대로\\n\\n[React Query](https://tanstack.com/query/latest) 훅은 API 함수만 호출하므로 수정할 필요가 없다.\\n\\n```typescript\\n// queries/useMutationAuth.ts\\nexport const useVerifySignup = () =\u003e {\\n  return useMutation({\\n    mutationFn: ({ email, code }: VerifySignupParams) =\u003e authApi.verifySignup(email, code),\\n    onSuccess: data =\u003e {\\n      setTokens(data.accessToken, data.refreshToken);\\n    },\\n  });\\n};\\n```\\n\\nAPI 레이어만 교체했으므로 컴포넌트 코드는 전혀 수정하지 않아도 된다.\\n\\n## 10. axios 제거\\n\\n마이그레이션이 완료되면 axios를 제거한다.\\n\\n```bash\\nyarn remove axios\\n```\\n\\n기존에 axios를 사용하던 파일들도 삭제한다.\\n\\n```bash\\nrm api/client.ts  # axios 클라이언트\\n```\\n\\n## 결과\\n\\n### 타입 안전성 확보\\n\\n이제 백엔드가 API를 변경하면 프론트엔드가 **컴파일 타임에** 에러가 발생한다.\\n\\n```typescript\\n// proto에서 nickname 필드가 제거되면\\nconst profile = await profileApi.getMe();\\nconsole.log(profile.nickname); // ❌ TypeScript 에러: 'nickname' does not exist\\n```\\n\\n### 개발 경험 개선\\n\\n1. **자동 완성이 정확하다** - proto에 정의된 필드만 자동 완성됨\\n2. **리팩토링이 안전하다** - 필드명을 바꾸면 사용하는 모든 곳에서 에러 발생\\n3. **문서가 필요 없다** - proto 파일이 곧 API 명세서\\n\\n### 유지보수 비용 감소\\n\\n- 타입 정의를 수동으로 관리할 필요 없음\\n- snake_case ↔ camelCase 변환 코드 불필요\\n- API 변경 시 영향받는 코드를 TypeScript가 알려줌\\n\\n## Binary vs JSON\\n\\nConnect RPC는 binary(Protobuf)와 JSON 두 가지 포맷을 지원한다. `createConnectTransport`는 기본적으로 binary 포맷을 사용하므로, 별도 설정 없이도 binary의 이점을 누릴 수 있다.\\n\\n- **Binary (기본값)** - 더 작은 페이로드, 더 빠른 직렬화/역직렬화\\n- **JSON** - 디버깅이 쉬움 (네트워크 탭에서 내용 확인 가능)\\n\\nProto 스키마의 타입 안전성을 유지하면서 실제 통신 데이터 포맷은 선택할 수 있다는 것이 Connect RPC의 큰 장점이다. 개발 환경에서 디버깅이 필요하다면 JSON으로, 프로덕션에서는 Binary로 전환하는 것도 가능하다.\\n\\n```typescript\\nconst transport = createConnectTransport({\\n  baseUrl: API_URL,\\n  useBinaryFormat: false, // JSON 사용 (디버깅 시 편리)\\n  // useBinaryFormat을 생략하면 기본값인 true(binary)가 적용됨\\n});\\n```\\n\\n## 주의사항\\n\\n### 1. Metro 설정 필수\\n\\n`unstable_enablePackageExports`를 활성화하지 않으면 런타임 에러가 발생한다. 이 설정을 빠뜨리면 앱이 제대로 실행되지 않는다.\\n\\n### 2. Streaming은 미지원\\n\\nConnect RPC는 [Unary RPC](https://grpc.io/docs/what-is-grpc/core-concepts/#unary-rpc)만 지원한다. [Server Streaming](https://grpc.io/docs/what-is-grpc/core-concepts/#server-streaming-rpc)이나 [Bidirectional Streaming](https://grpc.io/docs/what-is-grpc/core-concepts/#bidirectional-streaming-rpc)은 React Native에서 작동하지 않는다.\\n\\n### 3. 코드 생성 타이밍\\n\\nproto 파일이 변경되면 `yarn generate`를 다시 실행해야 한다. submodule을 업데이트할 때마다 실행하는 것을 잊지 말자.\\n\\n```bash\\n# proto submodule 업데이트 후\\ngit submodule update --remote proto\\nyarn generate\\n```\\n\\nproto 파일은 Protobuf의 네이밍 규칙에 따라 snake_case를 사용하지만, Connect는 코드 생성 시 자동으로 TypeScript의 camelCase로 변환해준다.\\n\\n## 마무리\\n\\nREST API에서 Connect RPC로 마이그레이션하면서 가장 만족스러운 점은 **타입 안전성**이다. 백엔드가 API를 변경하면 프론트엔드가 런타임이 아닌 컴파일 타임에 깨지므로, 배포 전에 문제를 발견할 수 있다.\\n\\n수동으로 타입을 정의하던 시간을 아낄 수 있고, proto 파일만 보면 API 명세를 정확히 알 수 있어 문서를 별도로 관리할 필요도 없어졌다.\\n\\n백엔드와 프론트엔드가 상호완결성을 가지는 서비스 프로덕트라면 gRPC 도입을 고려 해보는 것도 나쁘지 않은 것 같다.\\n\"}}],[\"$\",\"$La\",\"2\",{\"post\":{\"slug\":\"macos-gui-app-node-path-fix\",\"meta\":{\"title\":\"macOS GUI 앱에서 nvm Node를 인식하지 못하는 문제 해결하기\",\"description\":\"VS Code 익스텐션이 Node를 찾지 못할 때\",\"date\":\"2025/01/16\",\"tags\":[\"macOS\",\"nvm\",\"Node.js\",\"PATH\",\"VS Code\"],\"categories\":[\"dev\",\"troubleshooting\"],\"thumbnail\":\"assets/images/posts/thumbnails/macos-gui-app-node-path-fix.png\"},\"content\":\"\\n# macOS GUI 앱에서 nvm Node를 인식하지 못하는 문제 해결하기\\n\\n프로젝트에서 i18n Ally 익스텐션을 사용하고 있었는데, 분명히 정상 작동하던 것이 어느 날 갑자기 고장났다. 로그를 확인해보니 이런 에러가 나오고 있었다\\n\\n```sh\\n🐛 Failed to load Error: Command failed: node \\\"/Users/bran/.windsurf/extensions/lokalise.i18n-ally-2.13.1-universal/node_modules/ts-node/dist/bin.js\\\" ...\\n/bin/sh: node: command not found\\n```\\n\\n터미널에서 `node --version`을 실행하면 정상적으로 `v22.18.0`이 출력되는데, VS Code나 Windsurf 같은 GUI 앱의 익스텐션에서는 Node를 찾을 수 없다는 것이다.\\n\\n## 문제의 원인\\n\\n### nvm의 동작 방식\\n\\nnvm은 **동적으로** PATH를 조작한다. 셸이 시작될 때 `.zshrc`나 `.bash_profile`에 있는 `nvm.sh` 스크립트가 실행되면서\\n\\n1. 현재 활성화된 Node 버전의 경로를 찾는다\\n2. 해당 경로를 PATH **맨 앞에** 추가한다\\n3. `nvm use \u003c버전\u003e` 명령을 실행하면 이전 경로를 제거하고 새 경로를 추가한다\\n\\n```bash\\n# 터미널에서 확인해보면 nvm Node 경로가 PATH 맨 앞에 있다\\n$ echo $PATH\\n/Users/bran/.nvm/versions/node/v22.18.0/bin:/opt/homebrew/bin:...\\n```\\n\\n### GUI 앱은 셸 설정을 읽지 않는다\\n\\n문제는 **macOS GUI 앱은 셸 설정 파일을 읽지 않는다**는 것이다.\\n\\n- Finder나 Dock에서 앱을 실행하면 `launchd`라는 시스템 데몬이 앱을 실행한다\\n- `launchd`는 `/etc/paths`와 `/etc/paths.d/` 디렉토리의 설정만 읽는다\\n- 사용자의 `.zshrc`나 `.bash_profile`은 완전히 무시된다\\n- 따라서 nvm의 동적 PATH 설정도 적용되지 않는다\\n\\n터미널을 열면 셸이 시작되면서 `.zshrc`를 읽어 nvm이 로드되지만, GUI 앱은 그런 과정 없이 바로 실행되기 때문에 nvm의 Node를 찾을 수 없는 것이다.\\n\\n## 해결 방법\\n\\n`/etc/paths.d/` 디렉토리에 nvm Node 경로를 추가하면 된다. 이렇게 하면 모든 GUI 앱이 시스템 시작 시 해당 경로를 PATH에 포함한다.\\n기왕 하는김에, nvm만큼 동적으로 대응할수는 없더라도 특정 버전에 의존하지는 않도록 default 버전을 바라보는 방식으로 추가했다.\\n\\n### 1. 현재 nvm 버전 확인\\n\\n```bash\\nnvm current\\n# v22.18.0\\n```\\n\\n### 2. nvm default alias 설정\\n\\n```bash\\nnvm alias default 22.18.0\\n```\\n\\nnvm은 `default`라는 이름으로 심볼릭 링크를 생성한다\\n\\n```\\n~/.nvm/versions/node/default -\u003e ~/.nvm/versions/node/v22.18.0\\n```\\n\\n### 3. /etc/paths.d/nvm 파일 생성\\n\\n```bash\\necho \\\"$HOME/.nvm/versions/node/default/bin\\\" | sudo tee /etc/paths.d/nvm\\n```\\n\\n위 명령어로 `/etc/paths.d/nvm` 파일이 생성되고, 다음 내용이 저장된다\\n\\n```\\n/Users/bran/.nvm/versions/node/default/bin\\n```\\n\\n여기까지 했으면 macOS 재부팅 시 적용이 될 것이다. 재부팅 하지 않고 즉시 변경사항을 반영하고 싶다면 다음 4번과 5번 단계를 추가로 거친다.\\n\\n### 4. Dock 재시작\\n\\n```bash\\nkillall Dock\\n```\\n\\n### 5. GUI 앱 재시작\\n\\nVS Code, Windsurf 등 Node를 사용하는 앱을 완전히 종료하고 다시 실행한다.\\n\\n## 작동 원리\\n\\n### GUI 앱에서\\n\\n이제 GUI 앱들은 다음과 같은 PATH를 가지게 된다\\n\\n```\\n/usr/local/bin\\n/System/Cryptexes/App/usr/bin\\n/usr/bin\\n/bin\\n/usr/sbin\\n/sbin\\n/Users/bran/.nvm/versions/node/default/bin  # 새로 추가됨\\n```\\n\\n`/etc/paths.d/` 디렉토리의 모든 파일 내용이 자동으로 PATH에 추가되는 것이다.\\n\\n### 터미널에서\\n\\n터미널에서는 여전히 nvm이 정상 작동한다\\n\\n1. 셸이 시작되면서 `.zshrc`의 `nvm.sh`가 실행된다\\n2. nvm이 동적으로 PATH 맨 앞에 Node 경로를 추가한다\\n3. `nvm use` 명령으로 프로젝트별로 다른 Node 버전을 자유롭게 사용할 수 있다\\n\\nnvm의 PATH가 `/etc/paths.d/nvm`보다 앞에 있기 때문에 터미널에서는 nvm이 우선순위를 가진다.\\n\\n### default 심볼릭 링크의 장점\\n\\n`default` 심볼릭 링크를 사용했기 때문에\\n\\n```bash\\n# GUI 앱의 기본 Node 버전을 변경하고 싶다면\\nnvm alias default 18.0.0\\n\\n# Dock 재시작\\nkillall Dock\\n\\n# 이제 GUI 앱들은 v18.0.0을 사용한다\\n```\\n\\n절대 경로 대신 `default` 심볼릭 링크를 사용하면 `/etc/paths.d/nvm` 파일을 수정할 필요 없이 nvm alias만 바꾸면 된다.\\n\\n## 결과\\n\\n이제 GUI로 실행하는 앱들도 node를 찾을 수 있다.\\n그리고 내 IDE의 i18n Ally 익스텐션도 정상적으로 작동한다.\\n\\n```\\n✅ Loading finished\\n📂 Loading locales under /Users/bran/my-project/src/constants/locales\\n    📑 Loading (en) en.ts\\n    📑 Loading (ko) ko.ts\\n```\\n\\n## 요약\\n\\n- **문제**: macOS GUI 앱은 셸 설정 파일을 읽지 않아 nvm Node를 찾지 못함\\n- **원인**: GUI 앱은 `launchd`가 실행하며, `/etc/paths`와 `/etc/paths.d/`만 참조함\\n- **해결**: `/etc/paths.d/nvm`에 nvm default 경로를 추가\\n- **효과**:\\n  - GUI 앱에서 Node 사용 가능\\n  - 터미널에서는 여전히 nvm으로 프로젝트별 버전 관리 가능\\n  - `nvm alias default`로 GUI 앱의 기본 버전 변경 가능\\n\\n이 방법은 VS Code 익스텐션뿐만 아니라 Electron 앱 등 Node를 필요로 하는 모든 macOS GUI 앱에 적용할 수 있다.\\n\"}}],[\"$\",\"$La\",\"3\",{\"post\":{\"slug\":\"finicky-slack-chrome-profile-guide\",\"meta\":{\"title\":\"macOS에서 Slack 링크를 원하는 Chrome 프로필로 열기 (Finicky 사용)\",\"description\":\"크롬을 조금 더 스마트하게 써보자\",\"date\":\"2024/12/13\",\"tags\":[\"finicky\",\"chrome\",\"slack\"],\"categories\":[\"dev\",\"enhancement\"],\"thumbnail\":\"assets/images/posts/thumbnails/finicky-slack-chrome-profile-guide.png\"},\"content\":\"\\n# macOS에서 Slack 링크를 원하는 Chrome 프로필로 열기 (Finicky 사용)\\n\\n나는 회사 일과 개인 활동을 분리하려고 Chrome 프로필을 따로 쓴다. 그런데 macOS에서 Slack이나 mail 같은 앱에서 링크를 클릭하면 **무조건 시스템 기본 프로필로만 열린다**.\\n\\nSlack에서 회사 Jira 링크를 클릭했는데 개인 프로필로 열려서 로그인이 안 되어 있거나, 반대로 YouTube 링크가 회사 프로필로 열려 프리미엄 계정이 있음에도 광고를 보는 상황이 하루에도 몇 번씩 생긴다. 그럴 때마다 프로필 바꾸고 새로고침하는 게 퍽 번거롭다. 개발자스럽게 해결해보자.\\n\\n`Finicky`라는 앱을 찾았다. 이걸 쓰면 **링크의 출처나 도메인에 따라 자동으로 원하는 Chrome 프로필로 열 수 있다**.\\n\\n## 1. [Finicky](https://github.com/johnste/finicky) 설치\\n\\n```bash\\nbrew install --cask finicky\\n```\\n\\n설치 후 macOS 시스템 설정에서 **기본 웹 브라우저를 Finicky로 지정**한다:\\n\\n```\\n시스템 설정 \u003e 데스크탑 및 Dock \u003e 기본 웹 브라우저\\n```\\n\\n**중요**: Finicky가 제대로 동작하려면 반드시 시스템의 기본 브라우저로 설정되어 있어야 한다. 다른 앱(Slack, Mail 등)에서 링크를 클릭하면 기본 브라우저가 실행되는데, 이때 Finicky가 중간에서 설정에 따라 적절한 브라우저와 프로필을 선택해서 열어주는 방식이다.\\n\\n## 2. Chrome 프로필 이름 확인\\n\\nChrome에서 아래 주소를 열어 현재 프로필의 **폴더명**과 **사용자 지정 이름**을 확인한다:\\n\\n```\\nchrome://version\\n```\\n\\n예시:\\n\\n```\\nProfile Path: /Users/username/Library/Application Support/Google/Chrome/Profile 2\\n```\\n\\n- `Default`: 첫 번째 프로필\\n- `Profile 1`, `Profile 2` ...: 이후 생성된 프로필\\n- 사용자 이름은 오른쪽 상단 프로필 버튼 또는 `chrome://settings/people`에서 확인 가능\\n\\n## 3. Finicky 설정 파일 작성\\n\\n홈 디렉토리에 `~/.finicky.js` 파일을 만들고 이곳에 설정을 작성하면 된다.\\n\\n나의 경우 아래와 같이 설정했다\\n\\n- Slack에서 열리는 링크는 전부 회사 프로필로\\n- 회사 Jira, GitHub organization, Figma도 회사 프로필로\\n- YouTube는 프리미엄이 있는 개인 프로필로\\n- 나머지는 다 개인 프로필(기본값)\\n\\n```javascript\\nexport default {\\n  defaultBrowser: {\\n    name: 'Google Chrome',\\n    profile: 'Personal', // 기본값으로 사용할 프로필\\n  },\\n  handlers: [\\n    {\\n      match: url =\u003e url.hostname.includes('youtube') || url.hostname.includes('youtu.be'),\\n      browser: {\\n        name: 'Google Chrome',\\n        profile: 'Personal', // YouTube Premium 계정이 설정된 프로필\\n      },\\n    },\\n    {\\n      match: url =\u003e url.hostname === 'company.atlassian.net',\\n      browser: {\\n        name: 'Google Chrome',\\n        profile: 'Work',\\n      },\\n    },\\n    {\\n      match: url =\u003e url.hostname === 'github.com' \u0026\u0026 url.pathname.startsWith('/company-org'),\\n      browser: {\\n        name: 'Google Chrome',\\n        profile: 'Work',\\n      },\\n    },\\n    {\\n      match: url =\u003e url.hostname.includes('www.figma.com'),\\n      browser: {\\n        name: 'Google Chrome',\\n        profile: 'Work',\\n      },\\n    },\\n    {\\n      match: (_url, app) =\u003e app.opener \u0026\u0026 app.opener.bundleId === 'com.tinyspeck.slackmacgap',\\n      browser: {\\n        name: 'Google Chrome',\\n        profile: 'Work',\\n      },\\n    },\\n  ],\\n};\\n```\\n\\nhandlers는 **위에서부터 순차적으로 평가**되며, 첫 번째로 매칭되는 규칙이 적용된다. 그래서 YouTube 규칙을 Slack bundleId 규칙보다 위에 배치했다. 만약 순서가 반대라면 Slack에서 YouTube 링크를 클릭해도 모두 Work 프로필로 열릴 것이다.\\n\\n## 4. 디버깅\\n\\n설정이 제대로 동작하는지 확인하려면 Finicky를 실행하고 **Troubleshoot** 탭을 열면 된다. 여기서 실시간 로그를 볼 수 있다.\\n\\n\u003cdiv style=\\\"text-align: center;\\\"\u003e\\n  \u003cimg src=\\\"/assets/images/posts/finicky-slack-chrome-profile-guide/finicky-debug.png\\\" alt=\\\"Finicky Troubleshoot\\\" width=\\\"600\\\" /\u003e\\n\u003c/div\u003e\\n\\nmatch 함수 안에서 `console.log()`를 사용하면 필요한 데이터를 확인할 수 있다:\\n\\n```javascript\\n{\\n  match: (_url, app) =\u003e {\\n    console.log('URL:', _url.hostname);\\n    console.log('Opener:', app.opener?.bundleId);\\n    return app.opener \u0026\u0026 app.opener.bundleId === 'com.tinyspeck.slackmacgap';\\n  },\\n  browser: {\\n    name: 'Google Chrome',\\n    profile: 'Work',\\n  },\\n}\\n```\\n\\n이렇게 하면 어떤 앱에서 어떤 URL을 열었는지 정확히 알 수 있어서, 새로운 규칙을 추가할 때 유용하다.\\n\"}}],[\"$\",\"$La\",\"4\",{\"post\":{\"slug\":\"svg-from-scratch\",\"meta\":{\"title\":\"SVG 그려보기\",\"date\":\"2024/10/1\",\"tags\":[\"svg\",\"path\",\"progress\"],\"thumbnail\":\"assets/images/posts/thumbnails/svg-from-scratch.png\"},\"content\":\"\\nSVG(Scalable Vector Graphics)는 XML 기반의 마크업 언어로, 웹에서 확장 가능한 벡터 그래픽을 만드는 데 사용된다.\\n\\n## SVG 기본 이해\\n\\n1. 벡터 그래픽\\n   SVG는 벡터 기반 그래픽을 사용하여 이미지를 표현한다. 이는 이미지가 픽셀로 구성되어 있지 않고, 수학적인 수식으로 표현된다는 것을 의미하는데, 따라서 확대하거나 축소해도 이미지의 품질이 저하되지 않는다.\\n\\n2. XML 기반\\n   SVG는 XML을 사용하여 그래픽의 요소를 정의한다. 이 구조는 웹 기술과 잘 통합되므로, 웹 페이지 내에서 사용하기 쉽고 스크립트로 조작할 수도 있다.\\n\\n## SVG 주요 요소\\n\\n- `\u003csvg\u003e`: SVG 요소를 시작하는 루트 엘리먼트. 모든 다른 SVG 요소는 이 안에 포함된다.\\n- `\u003cpath\u003e`: 자유롭게 다양한 형태의 경로를 그릴 때 사용된다. d 프로퍼티에 M(이동), L(직선), H(수평선), V(수직선), C(큐빅 베지어 곡선), S(스무스 큐빅 베지어 곡선), Q(쿼드라틱 베지어 곡선), T(스무스 쿼드라틱 베지어 곡선), A(호)등의 명령을 통해 표현할 수 있다.\\n  `\u003crect\u003e`: 사각형\\n  `\u003ccircle\u003e`: 원\\n  `\u003cellipse\u003e`: 타원\\n  `\u003cline\u003e`: 두 점을 잇는 직선\\n  `\u003cpolyline\u003e` 및 `\u003cpolygon\u003e`: 여러 점을 연결해 도형을 만드는 엘리먼트\\n\\n## SVG 스타일링\\n\\nSVG 요소는 CSS를 통해 스타일링할 수 있다. fill, stroke, stroke-width, stroke-linecap, stroke-dasharray 등을 사용해 엘리먼트의 색상, 선 굵기, 선 종류 등을 정의할 수 있다.\\n\\n## Path\\n\\n- svg 안에서 거의 대부분을 path로 표현할 수 있다. 직선, 곡선, 호 등 다양한 형태의 경로를 만드는 것이 가능하고, d프로퍼티를 사용하여 도형의 경로를 정의한다.\\n\\n### 주요 명령어\\n\\n- M (moveto): 새로운 시작점으로 이동한다.\\n- L (lineto): 현재 위치에서 지정된 위치까지 직선을 그린다.\\n- H (horizontal lineto): 현재 위치에서 지정된 x 좌표까지 수평선을 그린다.\\n- V (vertical lineto): 현재 위치에서 지정된 y 좌표까지 수직선을 그린다.\\n- C (cubic Bézier curve): 세 점을 이용한 큐빅 베지어 곡선을 그린다. 첫 두 점은 컨트롤 포인트이고, 마지막 점은 곡선의 끝점이다.\\n- S (smooth cubic Bézier curve): 이전 C 또는 S 명령의 끝점을 기준으로 부드러운 큐빅 베지어 곡선을 그린다.\\n- Q (quadratic Bézier curve): 하나의 컨트롤 포인트와 끝점을 사용하는 쿼드라틱 베지어 곡선을 그린다.\\n- T (smooth quadratic Bézier curve): 이전 Q 또는 T 명령의 끝점을 기준으로 부드러운 쿼드라틱 베지어 곡선을 그린다.\\n- A (arc): 타원의 일부로 구성된 호를 그린다. 시작점에서 반지름, 각도, 방향, 끝점까지의 경로를 정의한다.\\n- Z (closepath): 현재 경로의 시작점과 끝점을 연결하여 도형을 닫는다.\\n\\n#### Bézier curve\\n\\nBézier 곡선은 \\\"제어점(control points)\\\"을 사용하여 정의하는 곡선으로, 곡선 자체는 항상 제어점을 직접 통과하지는 않지만 제어점에 영향을 받아 형태가 결정된다.\\n\\n##### 종류\\n\\n- 선형(Linear) Bézier 곡선(제어점 두 개): 두 점을 직선으로 연결\\n- 이차(Quadratic) Bézier 곡선(제어점 세 개): 첫 번째와 두 번째 제어점 사이, 그리고 두 번째와 세 번째 제어점 사이에 선형 Bézier 곡선을 그리고, 이 두 곡선을 기반으로 중간 점을 계산하여 곡선을 생성\\n- 입방(Cubic) Bézier 곡선(제어점 네 개): 가장 일반적으로 사용되는 Bézier 곡선. 복잡한 형태와 전환 효과를 만들 수 있다.\\n\\n##### 사용 예\\n\\n- Bézier 곡선은 디지털 디자인(특히 벡터 기반 그래픽), 애니메이션, 그리고 컴퓨터 시뮬레이션에서 널리 사용된다. 예를 들어, 웹 개발에서는 CSS 애니메이션과 전환에 큐빅 베지어 곡선을 사용하여 움직임의 속도를 조절한다.\\n\\n### Progress bar로 동작하게 하기\\n\\n#### stroke-dasharray와 stroke-dashoffset\\n\\n- stroke-dasharray: 선의 표시 부분과 공백 부분의 길이를 정의한다. 예를 들어, stroke-dasharray=\\\"5, 3\\\"는 선을 5의 길이로 그린 후, 3의 길이만큼 공백을 두고 다시 반복하여 그린다.\\n\\n- stroke-dashoffset: stroke-dasharray에서 정의된 대쉬 패턴이 시작되는 지점을 조정한다. 이 값이 클수록 선의 시작 부분이 뒤로 밀리면서, 그려지는 선의 시작 지점이 변경된다.\\n\\n프로그레스 바는 이 두 값들을 사용해, 대쉬 패턴의 첫번째 칸을 넓고 크게 만들어 채워지는 정도를 조절하는 개념으로 접근한다.\\n\\n#### 예제\\n\\n원을 이용해 프로그레스 바를 만드는 예제. 원 전체를 한 바퀴 돌면서 진행률을 표시한다.\\n\\n```xml\\n\u003csvg width=\\\"120\\\" height=\\\"120\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"\u003e\\n\u003ccircle cx=\\\"60\\\" cy=\\\"60\\\" r=\\\"50\\\" fill=\\\"transparent\\\" stroke=\\\"#ddd\\\" stroke-width=\\\"10\\\"/\u003e\\n\u003ccircle cx=\\\"60\\\" cy=\\\"60\\\" r=\\\"50\\\" fill=\\\"transparent\\\" stroke=\\\"blue\\\" stroke-width=\\\"10\\\"\\n          stroke-dasharray=\\\"314\\\" stroke-dashoffset=\\\"314\\\"/\u003e\\n\u003c/svg\u003e\\n```\\n\\n원의 둘레는 약 `314(2 * π * 50)`\\n\\n- `stroke-dasharray=\\\"314\\\"`: 원 전체를 하나의 대쉬로 만든다.\\n- `stroke-dashoffset=\\\"314\\\"`: 최초 상태에서는 진행 부분이 보이지 않는다. 진행률에 따라 이 값을 0까지 줄여감으로써 원하는 비율만큼 \\\"파란색\\\" 선이 나타나게 할 수 있다.\\n\\n#### 진행률에 따라 stroke-dashoffset 조정하기\\n\\n예를 들어, 진행률이 50%인 경우 stroke-dashoffset을 원의 둘레의 절반인 157로 설정한다.\\n\\n```javascript\\nconst progress = 50; // 진행률\\nconst circle = document.querySelector('circle');\\nconst circumference = 2 _ Math.PI _ 50; // 원의 둘레 계산\\n\\ncircle.style.strokeDashoffset = circumference \\\\* (1 - progress / 100);\\n```\\n\\n이제 진행률에 따라 원형 프로그레스 바가 시각적으로 업데이트된다.\\n\"}}],[\"$\",\"$La\",\"5\",{\"post\":{\"slug\":\"introduce-mermaid\",\"meta\":{\"title\":\"Mermaid - Markdown에서 다이어그램 그리기\",\"date\":\"2024/08/1\",\"tags\":[\"mermaid\",\"flowchart\",\"diagram graph\",\"다이어그램\",\"Markdown\",\"시각화\",\"개발 도구\"],\"thumbnail\":\"assets/images/posts/thumbnails/mermaid.png\"},\"content\":\"\\n개발 문서나 기술 블로그를 작성할 때 다이어그램은 개념을 시각적으로 쉽게 이해할 수 있도록 돕는 중요한 요소다. 그런데 기존의 다이어그램 작성 도구는 이미지 파일로 다이어그램을 관리해야 하고, 수정할 때마다 번거롭다. 이 문제를 해결하기 위해 \\\"Mermaid\\\"라는 도구를 알게 되어 소개한다.\\n\\n# Mermaid란?\\n\\nMermaid는 Markdown 파일 내에서 다이어그램을 코드로 작성할 수 있게 해주는 도구다. 복잡한 GUI 없이도 간단한 텍스트 코드로 여러 종류의 다이어그램을 그릴 수 있어 개발자에게 매우 유용하다. 특히 GitHub, GitLab 같은 플랫폼에서 지원되기 때문에 별도의 설치 없이도 다이어그램을 바로 확인할 수 있다.\\n\\n# 장점\\n\\n다이어그램을 텍스트 코드로 작성할 수 있다는 점이 가장 큰 장점이다. 코드 기반으로 다이어그램을 작성하면 버전 관리를 통해 이력을 남기거나 협업 시 수정 사항을 트래킹할 수 있다. 또한 텍스트로 표현되므로 파일 용량이 작고, 쉽게 수정할 수 있어 반복적으로 업데이트되는 프로젝트에 적합하다.\\n\\nMermaid는 다음과 같은 다이어그램을 지원한다:\\n\\n- 플로우차트(Flowchart)\\n- 시퀀스 다이어그램(Sequence Diagram)\\n- 간트차트(Gantt Chart)\\n- 클래스 다이어그램(Class Diagram)\\n- 상태도(State Diagram)\\n- 파이 차트(Pie Chart)\\n- ER 다이어그램(Entity Relationship Diagram)\\n\\n# 간단한 사용법\\n\\nMermaid 문법은 직관적이고 간단하다. 기본적인 플로우차트 예시를 보자.\\n\\n```mermaid\\ngraph TD\\nA[Start] --\u003e B{조건 확인}\\nB --\u003e|조건 만족| C[처리 A]\\nB --\u003e|조건 불만족| D[처리 B]\\nC --\u003e E[종료]\\nD --\u003e E[종료]\\n```\\n\\n위 코드를 작성하면, 다음과 같은 플로우차트가 그려진다:\\n\\n\u003cdiv style=\\\"text-align: center;\\\"\u003e\\n  \u003cimg src=\\\"/assets/images/posts/introduce-mermaid/mermaid-example.png\\\" alt=\\\"다이어그램\\\" width=\\\"400\\\" /\u003e\\n\u003c/div\u003e\\n\\n- A에서 시작해 B에서 조건을 확인하고,\\n- 조건을 만족하면 C로, 그렇지 않으면 D로 이동한다.\\n- 최종적으로 C와 D는 E로 이어져 종료된다.\\n\\nMermaid의 큰 장점은 이렇게 간단한 텍스트 코드로도 직관적인 다이어그램을 만들 수 있다는 점이다.\\n\\n# Mermaid 적용 방법\\n\\nMermaid를 적용하려면 기본적으로 다음과 같은 방식으로 접근할 수 있다:\\n\\n- Markdown 파일 내에서 사용\\n  GitHub, GitLab 같은 플랫폼에서는 바로 지원된다. 코드블록 안에 mermaid를 선언한 후 다이어그램을 그리는 코드를 작성하면 된다.\\n\\n- Mermaid Live Editor 사용\\n  공식 사이트의 Mermaid Live Editor에서 실시간으로 다이어그램을 작성하고 결과를 확인할 수 있다. 이 도구는 코드 작성 후 다이어그램을 바로 확인할 수 있어 유용하다.\\n\\n- HTML 페이지에 직접 삽입\\n  웹 프로젝트에서 Mermaid.js 라이브러리를 로드하고, HTML 내에 \u003cdiv\u003e 태그와 Mermaid 코드를 삽입하여 다이어그램을 표시할 수 있다.\\n\\n# 마무리\\n\\nMermaid는 Markdown을 활용해 빠르고 효율적으로 다이어그램을 그릴 수 있는 강력한 도구다. 협업과 버전 관리가 용이하며, 다양한 다이어그램을 지원해 프로젝트의 문서화에 큰 도움이 된다. 아직 사용해 보지 않았다면, Mermaid를 통해 더 나은 시각적 문서를 작성해보자.\\n\"}}],[\"$\",\"$La\",\"6\",{\"post\":{\"slug\":\"mysql-dockerize-2\",\"meta\":{\"title\":\"mysql dockerize(2) - mysql container에 볼륨 설정하기\",\"date\":\"2021/11/13\",\"description\":\"로컬 환경을 안전하게 보호하기 위해 MySQL을 도커로 격리하여 실행하는 과정을 기록한다.\",\"thumbnail\":\"assets/images/posts/thumbnails/mysql-dockerize.jpeg\",\"tags\":[\"container\",\"docker\",\"mysql\",\"volume\",\"도커\",\"볼륨\"]},\"content\":\"\\n## 지속적으로 사용할 수 있는 DB 만들기\\n\\n도커 컨테이너는 프로세스가 종료되면 내부에서 일어난 변경사항들이 모두 사라진다. 재부팅을 하거나 컨테이너가 삭제되면, 그동안 생성한 데이터들이 모두 초기화된다. 이를 방지하기 위해 도커는 데이터를 유지할 수 있는 \\\"볼륨\\\" 기능을 제공한다.\\nMySQL 이미지는 이 기능을 내부적으로 사용하고 있어서, 컨테이너를 생성할 때 자동으로 볼륨을 만든다. 하지만 이렇게 만들어진 볼륨은 컨테이너를 삭제하면 함께 사라지기 때문에, 데이터를 별도로 관리하고자 한다.\\n\\n### 볼륨\\n\\n도커 공식 문서에서는 이렇게 설명하고 있다.\\n\\n\u003e Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.\\n\u003e While bind mounts are dependent on the directory structure and OS of the host machine, volumes are completely managed by Docker.\\n\\n볼륨은 데이터 보존을 위한 기본 메커니즘이다. 운영 체제의 디렉토리 구조에 의존하는 `Bind mount`와 달리, 볼륨은 도커가 자체적으로 관리하기 때문에 실행 중인 운영 체제에 영향을 받지 않는다는 장점이 있다.\\n\\n### 볼륨 확인\\n\\n우선 MySQL 컨테이너에서 기본적으로 생성되는 볼륨을 확인해보자.\\n\\n```shell\\n$ docker run --name mysql -e MYSQL_ROOT_PASSWORD=1234 -d mysql\\ne94b0ab7eed5b1d147147ffe5b170d1520ee680f7b3ab7511e4e0fb4fb9a1925\\n\\n$  docker volume list\\nDRIVER    VOLUME NAME\\nlocal     b97c5432ff0a86802d2cbca69484448f1ecd5c530ddcad7e4b7eea3c6ec2e8c5\\n```\\n\\n`docker volume list` 명령어로 볼륨 목록을 확인하면, 자동으로 생성된 임의의 해시값이 볼륨 이름으로 나타난다. 이제 컨테이너를 삭제하고 다시 실행해보자.\\n\\n```shell\\n$ docker stop mysql\\nmysql\\n\\n$ docker rm mysql\\nmysql\\n\\n$ docker run --name mysql -e MYSQL_ROOT_PASSWORD=1234 -d mysql\\n456be35825bc8b1b7d2a4494c8b160ab578730f31a625a775abea271b036eae7\\n\\n$ docker volume list\\nDRIVER    VOLUME NAME\\nlocal     6765f342d98d3f274a0d7c3b137e07e48e9c153764e372707b6d987018498e6d\\nlocal     b97c5432ff0a86802d2cbca69484448f1ecd5c530ddcad7e4b7eea3c6ec2e8c5\\n```\\n\\n이전 볼륨이 삭제되지 않고 새로운 볼륨이 생성된 것을 확인할 수 있다. 컨테이너 안에서 데이터를 생성해본 후 다시 컨테이너를 삭제하고 재실행하면, 데이터가 없어져 있음을 확인할 수 있다.\\n\\n### 볼륨에 이름 부여하기\\n\\n컨테이너를 실행할 때 `-v {볼륨 이름||로컬 경로}:{컨테이너 안 경로}`또는 `--volume={볼륨 이름||로컬 경로}:{컨테이너 안 경로}` 옵션을 부여하여 볼륨을 직접 설정할 수 있다. mysql 이미지 안에서 볼륨은 `/var/lib/mysql`에 마운트되므로, 해당 경로와 함께 원하는 볼륨 이름을 지정하면 된다. 아래에서는 `mysql-volume`이라는 이름으로 설정했다.\\n\\n```shell\\n$ docker run --name mysql -e MYSQL_ROOT_PASSWORD=1234 -v mysql-volume:/var/lib/mysql -d mysql\\n```\\n\\n이제 볼륨 목록을 다시 확인해보자.\\n\\n```shell\\n$ docker volume list\\nDRIVER    VOLUME NAME\\nlocal     6765f342d98d3f274a0d7c3b137e07e48e9c153764e372707b6d987018498e6d\\nlocal     b97c5432ff0a86802d2cbca69484448f1ecd5c530ddcad7e4b7eea3c6ec2e8c5\\nlocal     mysql-volume\\n```\\n\\nmysql-volume이라는 이름의 볼륨이 생성된 것을 확인할 수 있다. 이제 컨테이너를 삭제하더라도, 볼륨을 제거하지 않는 한 동일한 볼륨을 계속 사용할 수 있다.\\n\\n### 볼륨 삭제하기\\n\\n불필요한 볼륨은 삭제할 수 있다. 삭제하는 방법은 다음과 같다.\\n\\n1. 컨테이너를 삭제할 때 볼륨도 함께 삭제하는 방법\\n\\n```shell\\n$ docker rm -v mysql\\n```\\n\\n2. 볼륨 리스트에서 특정 볼륨을 직접 삭제하는 방법\\n\\n```shell\\n$ docker volume rm 6765f342d98d3f274a0d7c3b137e07e48e9c153764e372707b6d987018498e6d\\n```\\n\\n3. 로컬에 생성되어 있지만, 어떤 컨테이너에도 연결되지 않은 \\\"dangling\\\" 상태의 모든 볼륨을 삭제하는 방법\\n\\n```shell\\n$ docker volume prune\\n```\\n\"}}],[\"$\",\"$La\",\"7\",{\"post\":{\"slug\":\"mysql-dockerize\",\"meta\":{\"title\":\"mysql dockerize(1) - 도커로 mysql container 띄우기\",\"date\":\"2021/11/07\",\"description\":\"로컬 환경을 안전하게 보호하기 위해 MySQL을 도커로 격리하여 실행하는 과정을 기록한다.\",\"tags\":[\"MYSQL_ALLOW_EMPTY_PASSWORD\",\"MYSQL_RANDOM_ROOT_PASSWORD\",\"MYSQL_ROOT_PASSWORD\",\"container\",\"docker\",\"mysql\"],\"thumbnail\":\"assets/images/posts/thumbnails/mysql-dockerize.jpeg\"},\"content\":\"\\n최근 작업 중 DB 스키마 변경이 로컬 개발 환경에 영향을 미치는 일이 자주 발생했다. 이를 방지하기 위해 로컬에서 실행 중인 MySQL을 도커로 격리하여 실행하기로 했다.\\n\\n## 시작점\\n\\n현재 사용 중인 DB는 MySQL이며, Ruby on Rails(RoR) 프로젝트를 진행 중이다. 로컬 환경에 MySQL 서버가 설치되어 있고, Docker는 이미 설치되어 있다.\\n\\n## 도커로 mysql container 띄우기\\n\\n### mysql 이미지 가져오기\\n\\n먼저 MySQL 이미지를 가져온다.\\n\\n```shell\\n$ docker pull mysql\\n\\nUsing default tag: latest\\nlatest: Pulling from library/mysql\\n...\\n...\\nDigest: ...\\nStatus: Downloaded newer image for mysql:latest\\ndocker.io/library/mysql:latest\\n```\\n\\nLTS 버전의 MySQL 이미지가 로드된다.\\n\\n### mysql 이미지를 컨테이너로 실행하기\\n\\n로드한 이미지를 컨테이너로 실행해본다.\\n\\n```shell\\n$ docker run mysql\\n\\n2021-11-07 07:55:25+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.27-1debian10 started.\\n2021-11-07 07:55:25+00:00 [Note] [Entrypoint]: Switching to dedicated user 'mysql'\\n2021-11-07 07:55:25+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.27-1debian10 started.\\n2021-11-07 07:55:25+00:00 [ERROR] [Entrypoint]: Database is uninitialized and password option is not specified\\n    You need to specify one of the following:\\n    - MYSQL_ROOT_PASSWORD\\n    - MYSQL_ALLOW_EMPTY_PASSWORD\\n    - MYSQL_RANDOM_ROOT_PASSWORD\\n```\\n\\n에러가 발생한다. MySQL 컨테이너는 루트 사용자의 비밀번호 설정 방법을 명시해야 한다. 아래 세 가지 옵션 중 하나를 선택해 컨테이너의 환경 변수로 전달한다.\\n\\n```shell\\n$ docker run mysql -e MYSQL_ROOT_PASSWORD=1234\\n# 또는\\n$ docker run mysql -e MYSQL_ALLOW_EMPTY_PASSWORD=abcd\\n# 또는\\n$ docker run mysql -e MYSQL_RANDOM_ROOT_PASSWORD=abcd\\n```\\n\\n루트 비밀번호를 지정해주었다. 비밀번호를 설정하지 않는 MYSQL_ALLOW_EMPTY_PASSWORD나 MYSQL_RANDOM_ROOT_PASSWORD 옵션도 환경 변수에 값을 지정해줘야 동작한다. 실제로 해당 값이 영향을 미치지는 않는다.\\n\\n랜덤 비밀번호 옵션을 사용하면 실행 로그에 비밀번호가 표시된다.\\n\\n```shell\\n2021-11-07 07:55:40+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.27-1debian10 started.\\n2021-11-07 07:55:40+00:00 [Note] [Entrypoint]: Switching to dedicated user 'mysql'\\n...\\n...\\n2021-11-07 07:55:48+00:00 [Note] [Entrypoint]: GENERATED ROOT PASSWORD: ojai1toovee3jahC4ooh7on8ahjoo0ji\\n...\\n2021-11-07 07:55:50+00:00 [Note] [Entrypoint]: MySQL init process done. Ready for start up.\\n...\\n2021-11-07T07:55:51.690474Z 0 [System] [MY-011323] [Server] X Plugin ready for connections. Bind-address: '::' port: 33060, socket: /var/run/mysqld/mysqlx.sock\\n2021-11-07T07:55:51.690582Z 0 [System] [MY-010931] [Server] /usr/sbin/mysqld: ready for connections. Version: '8.0.27'  socket: '/var/run/mysqld/mysqld.sock'  port: 3306  MySQL Community Server - GPL.\\n```\\n\\n컨테이너가 정상적으로 실행되었는지 확인한다.\\n\\n```shell\\n$ docker ps\\n\\nCONTAINER ID   IMAGE      COMMAND                  CREATED         STATUS          PORTS                    NAMES\\nddb780457980   mysql      \\\"docker-entrypoint.s…\\\"   4 minutes ago   Up 4 minutes    3306/tcp, 33060/tcp      musing_dewdney\\n```\\n\\n### 컨테이너 실행 결과 확인하기\\n\\n터미널을 하나 더 열어 방금 띄운 MySQL 컨테이너에 접속할 수 있다. 지정한 비밀번호로 MySQL 클라이언트에 접속해본다.\\n\\n```shell\\n$ docker exec -it musing_dewdney bash\\n\\nroot@ddb780457980:/# mysql -uroot -p1234\\n\\nmysql: [Warning] Using a password on the command line interface can be insecure.\\nWelcome to the MySQL monitor.  Commands end with ; or \\\\g.\\nYour MySQL connection id is 9\\nServer version: 8.0.27 MySQL Community Server - GPL\\n\\nCopyright (c) 2000, 2021, Oracle and/or its affiliates.\\n\\nOracle is a registered trademark of Oracle Corporation and/or its\\naffiliates. Other names may be trademarks of their respective\\nowners.\\n\\nType 'help;' or '\\\\h' for help. Type '\\\\c' to clear the current input statement.\\n\\nmysql\u003e\\n```\\n\\n### 옵션 추가\\n\\nMySQL 서버는 항상 실행되어 있어야 하므로 데몬 모드로 실행하는 것이 일반적이다. 또한, 컨테이너에 접근하기 쉽게 이름을 지정할 수 있다.\\n이미 실행 중인 컨테이너를 정지하고 삭제한 후, 몇 가지 옵션을 추가하여 새로 띄운다.\\n\\n```shell\\n$ docker kill musing_dewdney\\n\\n$ docker rm musing_dewdney\\n\\n$ docker run --name mysql -e MYSQL_ROOT_PASSWORD=1234 -d mysql\\n```\\n\\n성공적으로 실행되었다면, 아까와 같이 컨테이너 내부에 접속하여 확인할 수 있다.\\n\\n```\\n$ docker exec -it mysql bash\\n```\\n\"}}],[\"$\",\"$La\",\"8\",{\"post\":{\"slug\":\"command-tsc-is-not-found\",\"meta\":{\"title\":\"Command 'tsc' is not found\",\"date\":\"2021/10/01\",\"tags\":[\"NestJS\",\"Node\",\"tsc\",\"typescript\"],\"thumbnail\":\"assets/images/posts/thumbnails/command-tsc-is-not-found.png\"},\"content\":\"\\nNode.js 환경에서 NestJS 프레임워크를 사용하기 위해 TypeScript를 설정하다가 `Command 'tsc' is not found`라는 에러가 발생했다. 분명 여러 번 tsc를 설치했음에도 불구하고, 명령어를 찾을 수 없다고 나오며, 라이브러리 리스트에서는 설치가 완료된 것으로 보였다. Yarn과 npm을 모두 사용해 봤지만 결과는 같았다.\\n\\n여러 레퍼런스를 찾은 끝에 해결책을 찾았고, 이를 기록으로 남긴다.\\n\\n```shell\\nexport PATH=\\\"$PATH:/Users/narb/.npm-global/lib/node_modules/typescript/bin\\\"\\n\\nexport PATH=\\\"$PATH:/Users/narb/.npm-global/bin\\\"\\n```\\n\\n문제는 결국 명령어가 위치한 경로를 터미널이 찾지 못했던 것이었다. npm 설치 시 별도로 PATH 설정을 해야 하는지는 불분명하지만, 내 로컬 환경에서는 PATH가 설정되어 있지 않아서 이 문제가 발생했다.\\n\\n위의 `PATH` 추가 구문을 터미널 설정 파일(예: .zshrc, .bash_profile)에 추가하면 된다. 먼저 두 번째 줄의 코드를 시도해 보고, 문제가 해결되지 않으면 첫 번째 줄도 추가해 보는 것이 좋다. 나는 zsh을 사용 중이어서 ~/.zshrc에 추가했지만, bash를 사용하고 있다면 ~/.bash_profile에 넣으면 된다.\\n\\n파일을 수정한 후에는 터미널을 재시작하거나 `source ~/.zshrc` 명령어를 실행하면 된다. 이후 `tsc` 명령어가 정상적으로 동작하는 것을 확인할 수 있다.\\n\"}}],[\"$\",\"$La\",\"9\",{\"post\":{\"slug\":\"rds-dump\",\"meta\":{\"title\":\"AWS RDS의 Data base를 dump하기\",\"description\":\"VPC 내부에 있는 RDS에서 데이터베이스를 덤프하고, 이를 로컬 MySQL로 복구하는 과정에서 겪은 문제들을 기록한다.\",\"date\":\"2021/09/14\",\"tags\":[\"COLUMN_STATISTICS\",\"NO_AUTO_CREATE_USER\",\"column-statistics=0\",\"mysqldump\",\"sed\",\"sql_mode\",\"ssh tunneling\"],\"thumbnail\":\"assets/images/posts/thumbnails/rds-dump.png\"},\"content\":\"\\n## ssh tunneling을 통해 DB dump해오기\\n\\n- mysqldump 명령어를 사용하여 .sql 파일 형태로 데이터베이스를 덤프할 수 있다.\\n- 이 과정에서는 터널링을 수행할 EC2 인스턴스에 MySQL 클라이언트가 설치되어 있어야 한다.\\n\\n```shell\\n$ ssh `tunneling-instanse-username`@`tunneling-instanse-host` -i `key-file-path` mysqldump -u`username` -p`password` -h `remote-db-host` `database-name` \u003e `local/path/to/save.sql`\\n```\\n\\n### COLUMN_STATISTICS\\n\\n#### 덤프 시도 중 `...: Unknown table 'COLUMN_STATISTICS' in information_schema` 라는 에러가 발생할 경우\\n\\n- 이 에러는 MySQL 8.0에서 새로 추가된 옵션인 COLUMN_STATISTICS 때문이다. 이 옵션은 테이블의 통계 데이터를 분석하여 덤프 시 포함하는 기능이다. \u003csup\u003e[레퍼런스](https://jay-ji.tistory.com/62)\u003c/sup\u003e\\n- 이 옵션을 비활성화하려면 덤프 명령어에 `--column-statistics=0`을 추가한다.\\n\\n```shell\\n$ ssh `tunneling-instanse-username`@`tunneling-instanse-host` -i `key-file-path` mysqldump -u`username` -p`password` -h `remote-db-host` --column-statistics=0 `database-name` \u003e `local/path/to/save.sql`\\n```\\n\\n#### 덤프 시도 중 `...unknown variable 'column-statistics=0'...` 라는 에러가 발생할 경우\\n\\n- 이 에러는 해당 옵션이 불필요한 경우 발생할 수 있다. 이런 경우에는 덤프 명령어에서 `--column-statistics=0`을 제거하고 다시 시도한다.\\n\\n## .sql파일을 로컬 mysql에 로드하기\\n\\n- 덤프한 .sql 파일을 로컬 데이터베이스에 로드할 때는 mysql 명령어를 사용한다.\\n- 데이터를 받을 데이터베이스는 미리 생성되어 있고 비어 있어야 한다.\\n\\n```shell\\n$ mysql -u`local-user-name` -p`local-pwd` `database-name` \u003c `path/for/dumped.sql`\\n```\\n\\n### NO_AUTO_CREATE_USER\\n\\n#### 로드 시도 중 `Variable 'sql_mode' can't be set to the value of 'NO_AUTO_CREATE_USER'` 라는 에러가 발생할 경우\\n\\n- 이 에러는 MySQL 8.0 이상 버전에서 발생하는데, 해당 모드는 사용자 생성 관련 모드다. MySQL 8.0 이상에서는 이 모드가 제거되었으며, 대신 `CREATE USER` 또는 `GRANT` 구문을 사용한다.\\n- 이 문제를 해결하려면 `dumped.sql` 파일을 수정해야 한다.\\n- .sql 파일은 매우 크기 때문에 일반 텍스트 에디터로 수정하는 것은 비효율적이다. 대신 `sed` 명령어를 사용해 빠르게 수정할 수 있다.\\n- `macOS`와 같은 `Unix` 계열 시스템에서는 다음과 같이 `sed` 명령어를 사용한다.\\n\\n```shell\\nsed -i '' 's/NO_AUTO_CREATE_USER//' `path/for/dumped.sql`\\n```\\n\\n- 수정한 후 다시 데이터를 로드하면 된다.\\n\"}}],[\"$\",\"$La\",\"10\",{\"post\":{\"slug\":\"trap-of-htmlcollection\",\"meta\":{\"title\":\"HTMLCollection의 함정\",\"description\":\"클래스를 기준으로 스크립트를 작성하다가 맞닥트린 예상치 못한 문제\",\"date\":\"2021/09/07\",\"tags\":[\"HTMLCollection\",\"getElementsByClassName\",\"nodeList\",\"querySelectorAll()\"],\"categories\":[\"dev\",\"web\"],\"thumbnail\":\"assets/images/posts/thumbnails/trap-of-htmlcollection.jpeg\"},\"content\":\"\\n```html\\n\u003cdiv class=\\\"wrapper lunchtime-template\\\"\u003e\\n  \u003cp class=\\\"title\\\"\u003e\\n    \u003cspan class=\\\"text-primary name-slot\\\"\u003eOOO\u003c/span\u003e\\n    의 점심시간\\n  \u003c/p\u003e\\n  \u003cul\u003e\\n    \u003cli class=\\\"text-info history-slot\\\"\u003e\u003c/li\u003e\\n    \u003cli class=\\\"text-info history-slot\\\"\u003e\u003c/li\u003e\\n    \u003cli class=\\\"text-info history-slot\\\"\u003e\u003c/li\u003e\\n    \u003cli class=\\\"text-info history-slot\\\"\u003e\u003c/li\u003e\\n  \u003c/ul\u003e\\n\u003c/div\u003e\\n```\\n\\n위와 같은 형태의 HTML 템플릿에 데이터를 넣는 작업이었다. 스크립트를 작성하면서, 먼저 알맞은 태그 요소를 찾아 데이터를 넣고, 템플릿으로 활용했던 클래스 이름들을 제거하려고 했다.\\n\\n```javascript\\nconst data = {\\n  bran: ['철판 볶음밥을 먹었다', '커피를 주문했다', '쿠키도 구매했다', '양치를 했다'],\\n};\\n\\nlet lunchTimeDiv = document.querySelector('.lunchtime-template').cloneNode(true);\\nlunchTimeDiv.classList.remove('lunchtime-template');\\n\\nlet name = Object.keys(data)[0];\\nlet nameSlot = lunchTimeDiv.querySelector('.name-slot');\\nnameSlot.innerHTML = name;\\nnameSlot.classList.remove('name-slot');\\n```\\n\\n여기까지는 별 문제 없었지만, 이후에 문제가 발생했다.\\n\\n```javascript\\nconst histories = data[name];\\nlet historySlots = lunchTimeDiv.getElementsByClassName('history-slot');\\nfor (let idx = 0; idx \u003c historySlots.length; idx++) {\\n  slot = historySlots[idx];\\n  slot.innerText = histories[idx];\\n  slot.classList.remove('history-slot');\\n}\\n```\\n\\n스크립트로 처리된 결과는 기대와 달랐다.\\n\\n```html\\n\u003cdiv class=\\\"wrapper\\\"\u003e\\n  \u003cp class=\\\"title\\\"\u003e\\n    \u003cspan class=\\\"text-primary\\\"\u003ebran\u003c/span\u003e\\n    의 점심시간\\n  \u003c/p\u003e\\n  \u003cul\u003e\\n    \u003cli class=\\\"text-info\\\"\u003e철판 볶음밥을 먹었다\u003c/li\u003e\\n    \u003cli class=\\\"text-info history-slot\\\"\u003e\u003c/li\u003e\\n    \u003cli class=\\\"text-info\\\"\u003e커피를 주문했다\u003c/li\u003e\\n    \u003cli class=\\\"text-info history-slot\\\"\u003e\u003c/li\u003e\\n  \u003c/ul\u003e\\n\u003c/div\u003e\\n```\\n\\n코드가 기대한 대로 작동하지 않아 어리둥절했다. 간단한 코드에서 문제가 발생하리라 예상하지 못했지만, 분명히 어디선가 잘못된 부분이 있었다.\\n고민 끝에, 루프 안에서 인덱스를 조절해야 했던 알고리즘 문제를 떠올리고 코드를 수정해 보았다.\\n\\n```javascript\\nfor (let idx = 0; idx \u003c histories.length; idx++) {\\n  slot = historySlots[idx];\\n  slot.innerText = histories[idx];\\n  slot.classList.remove('history-slot');\\n  idx -= 1;\\n}\\n```\\n\\n결과는 나왔지만, 뭔가 이상했다.\\n\\n```html\\n\u003cdiv class=\\\"wrapper\\\"\u003e\\n  \u003cp class=\\\"title\\\"\u003e\\n    \u003cspan class=\\\"text-primary\\\"\u003ebran\u003c/span\u003e\\n    의 점심시간\\n  \u003c/p\u003e\\n  \u003cul\u003e\\n    \u003cli class=\\\"text-info\\\"\u003e철판 볶음밥을 먹었다\u003c/li\u003e\\n    \u003cli class=\\\"text-info\\\"\u003e철판 볶음밥을 먹었다\u003c/li\u003e\\n    \u003cli class=\\\"text-info\\\"\u003e철판 볶음밥을 먹었다\u003c/li\u003e\\n    \u003cli class=\\\"text-info\\\"\u003e철판 볶음밥을 먹었다\u003c/li\u003e\\n  \u003c/ul\u003e\\n\u003c/div\u003e\\n```\\n\\n포문에서 발생한 문제는 어느 정도 해결됐지만, 데이터를 인덱스와 같이 순환해야 하므로 복잡성만 더 커졌을 뿐, 이 방식은 적절하지 않았다.\\n근본적인 문제를 고민해보니, `historySlots`가 루프가 진행됨에 따라 변하고 있었다. 그래서 `historySlots`를 잡는 방식을 `getElementsByClassName`에서 `querySelectorAll`로 바꿔보기로 했다.\\n\\n```html\\n\u003cdiv class=\\\"wrapper lunchtime-template\\\"\u003e\\n  \u003cp class=\\\"title\\\"\u003e\\n    \u003cspan class=\\\"text-primary name-slot\\\"\u003eOOO\u003c/span\u003e\\n    의 점심시간\\n  \u003c/p\u003e\\n  \u003cul\u003e\\n    \u003cli class=\\\"text-info history-slot\\\"\u003e\u003c/li\u003e\\n    \u003cli class=\\\"text-info history-slot\\\"\u003e\u003c/li\u003e\\n    \u003cli class=\\\"text-info history-slot\\\"\u003e\u003c/li\u003e\\n    \u003cli class=\\\"text-info history-slot\\\"\u003e\u003c/li\u003e\\n  \u003c/ul\u003e\\n\u003c/div\u003e\\n\\n\u003cscript\u003e\\n  const data = {\\n    bran: ['철판 볶음밥을 먹었다', '커피를 주문했다', '쿠키도 구매했다', '양치를 했다'],\\n  };\\n  let lunchTimeDiv = document.querySelector('.lunchtime-template').cloneNode(true);\\n  lunchTimeDiv.classList.remove('lunchtime-template');\\n\\n  let name = Object.keys(data)[0];\\n  let nameSlot = lunchTimeDiv.querySelector('.name-slot');\\n  nameSlot.innerHTML = name;\\n  nameSlot.classList.remove('name-slot');\\n  const histories = data[name];\\n\\n  // 이곳을 변경\\n  let historySlots = lunchTimeDiv.querySelectorAll('.history-slot');\\n\\n  for (let idx = 0; idx \u003c historySlots.length; idx++) {\\n    slot = historySlots[idx];\\n    slot.innerText = histories[idx];\\n    slot.classList.remove('history-slot');\\n  }\\n\u003c/script\u003e\\n```\\n\\n드디어 의도대로 동작했다.\\n\\n```html\\n\u003cdiv class=\\\"wrapper\\\"\u003e\\n  \u003cp class=\\\"title\\\"\u003e\\n    \u003cspan class=\\\"text-primary\\\"\u003ebran\u003c/span\u003e\\n    의 점심시간\\n  \u003c/p\u003e\\n  \u003cul\u003e\\n    \u003cli class=\\\"text-info\\\"\u003e철판 볶음밥을 먹었다\u003c/li\u003e\\n    \u003cli class=\\\"text-info\\\"\u003e커피를 주문했다\u003c/li\u003e\\n    \u003cli class=\\\"text-info\\\"\u003e쿠키도 구매했다\u003c/li\u003e\\n    \u003cli class=\\\"text-info\\\"\u003e양치를 했다\u003c/li\u003e\\n  \u003c/ul\u003e\\n\u003c/div\u003e\\n```\\n\\n---\\n\\n`getElementsByClassName`은 `HTMLCollection`을 반환하고, `querySelectorAll`은 `NodeList`를 반환한다.\\n\\n```javascript\\nlet historySlots1 = lunchTimeDiv.getElementsByClassName('history-slot');\\nlet historySlots2 = lunchTimeDiv.querySelectorAll('.history-slot');\\nconsole.log(historySlots1.toString()); // '[object HTMLCollection]'\\nconsole.log(historySlots2.toString()); //  '[object NodeList]'\\n```\\n\\n[HTMLCollection과 NodeList](https://dev.to/theoluyi/queryselector-vs-getelementsbyclassname-nodelist-vs-htmlcollection-30gg) 의 차이를 설명하는 좀 더 자세한 글을 첨부한다.\\n\\n간단하게 말하자면, HTMLCollection은 항상 현재 상황을 반영한다. 즉, 클래스 이름을 기준으로 요소들이 담기는데, 내가 클래스 이름을 지우면서 해당 컬렉션에서 제외된 것이다. 포문이 제대로 작동하지 않은 이유는 바로 이 때문이었다.\\n\\n더 나아가 HTMLCollection은 배열이 아닌 유사 배열이기 때문에 forEach 같은 배열 메서드를 사용할 수 없다. 하지만 객체 속성에 접근하듯이 .속성명 형식으로 접근이 가능하다. \u003csup\u003e[ref](https://devsoyoung.github.io/posts/js-htmlcollection-nodelist)\u003c/sup\u003e\\n\\n앞으로는 상황에 맞는 선택을 더 신중히 해야겠다.\\n\"}}]]}],null],\"segment\":\"__PAGE__\"},\"styles\":[]}],\"segment\":\"posts\"},\"styles\":[]}],\"params\":{}}],null]}]]\n"])</script><script>self.__next_f.push([1,"7:[[[\"$\",\"meta\",null,{\"charSet\":\"utf-8\"}],null,null,null,null,null,null,null,null,null,null,[\"$\",\"meta\",null,{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],null,null,null,null,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,null,null,null,null]\n"])</script><script>self.__next_f.push([1,"4:[[[\"$\",\"meta\",null,{\"charSet\":\"utf-8\"}],[\"$\",\"title\",null,{\"children\":\"Posts - Bran's codeverse\"}],[\"$\",\"meta\",null,{\"name\":\"description\",\"content\":\"개발하면서 배운 것들을 기록하고 공유합니다\"}],null,null,null,null,null,null,null,null,[\"$\",\"meta\",null,{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],null,null,null,null,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,[null,[\"$\",\"meta\",null,{\"property\":\"og:title\",\"content\":\"Posts - Bran's codeverse\"}],[\"$\",\"meta\",null,{\"property\":\"og:description\",\"content\":\"개발하면서 배운 것들을 기록하고 공유합니다\"}],null,[\"$\",\"meta\",null,{\"property\":\"og:site_name\",\"content\":\"Bran's codeverse\"}],null,null,null,[[[\"$\",\"meta\",null,{\"property\":\"og:image\",\"content\":\"http://localhost:3000/assets/images/default-thumbnail.jpg\"}]]],null,null,null,null,null,null,[\"$\",\"meta\",null,{\"property\":\"og:type\",\"content\":\"website\"}]],[[\"$\",\"meta\",null,{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",null,{\"name\":\"twitter:site\",\"content\":\"@codeverse\"}],null,null,null,[\"$\",\"meta\",null,{\"name\":\"twitter:title\",\"content\":\"Posts - Bran's codeverse\"}],[\"$\",\"meta\",null,{\"name\":\"twitter:description\",\"content\":\"개발하면서 배운 것들을 기록하고 공유합니다\"}],[[[\"$\",\"meta\",null,{\"name\":\"twitter:image\",\"content\":\"http://localhost:3000/assets/images/default-thumbnail.jpg\"}]]],null,null],null,[null,[[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/icon.svg?43070ac23468c58b\",\"type\":\"image/svg+xml\",\"sizes\":\"32x32\"}]],[],null]]\n"])</script></body></html>