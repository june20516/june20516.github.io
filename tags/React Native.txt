1:HL["/_next/static/css/0ad9df217a839d7d.css",{"as":"style"}]
0:[[["",{"children":["tags",{"children":[["tag","React%20Native","d"],{"children":["__PAGE__?{\"tag\":\"React Native\"}",{}]}]}]},"$undefined","$undefined",true],"$L2",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/0ad9df217a839d7d.css","precedence":"next"}]],["$L3",null]]]]
4:I{"id":"6886","chunks":["771:static/chunks/771-437baa63a3bc2c51.js","846:static/chunks/846-5374114718c3ba3f.js","218:static/chunks/218-24e2ed3a86df3181.js","185:static/chunks/app/layout-1a9b501ae2e54936.js"],"name":"","async":false}
5:I{"id":"4463","chunks":["272:static/chunks/webpack-932dee968bc237b7.js","667:static/chunks/2443530c-0538301a504b83cf.js","488:static/chunks/488-c0b34e96c35b33f7.js"],"name":"","async":false}
6:I{"id":"1010","chunks":["272:static/chunks/webpack-932dee968bc237b7.js","667:static/chunks/2443530c-0538301a504b83cf.js","488:static/chunks/488-c0b34e96c35b33f7.js"],"name":"","async":false}
7:I{"id":"5568","chunks":["771:static/chunks/771-437baa63a3bc2c51.js","846:static/chunks/846-5374114718c3ba3f.js","605:static/chunks/app/tags/[tag]/page-22609de8da84a426.js"],"name":"","async":false}
8:I{"id":"6640","chunks":["771:static/chunks/771-437baa63a3bc2c51.js","846:static/chunks/846-5374114718c3ba3f.js","605:static/chunks/app/tags/[tag]/page-22609de8da84a426.js"],"name":"","async":false}
2:[["$","$L4",null,{"children":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L6",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","tags","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L6",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","tags","children",["tag","React%20Native","d"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L6",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":[[["$","$L7",null,{"tag":"React Native","count":1}],["$","ol",null,{"children":[["$","$L8","0",{"post":{"slug":"react-native-connect-rpc-migration","meta":{"title":"React Native에서 REST API를 Connect RPC로 마이그레이션하기","description":"axios를 버리고 타입 안전한 gRPC 세상으로","date":"2026/01/05","tags":["React Native","Connect RPC","Protobuf","gRPC","typescript"],"categories":["dev","architecture"],"thumbnail":"assets/images/posts/thumbnails/react-native-connect-rpc-migration.png"},"content":"\n# React Native에서 REST API를 Connect RPC로 마이그레이션하기\n\nAPI 문서의 중요함은 웹 개발자들 사이에서 말하면 입아플 정도로 널리 공감되는 주제이다. 이를 위해 많은 도구들이 존재하고 다양한 노력들이 이루어졌다.\n나는 최근에 프로젝트를 진행하며 백엔드 입장에서 문서를 제공해야 했었고, 가져가기로 한 기술 스택에서 이 문서화 도구의 지원이 빈약함을 알게 되었다. 그래서 조금 더 많은 수작업이 필요해졌는데, 갑자기 회의감이 들었다. 코드와 코드의 대화 사이에 들어가는 사람의 손길, 이 헐거움이 어색하게 느껴졌다.\n이 문제를 근본적으로 해결하기 위해 REST API를 버리고 [Connect RPC](https://connectrpc.com/)로 전환하기로 결정했다. Connect RPC는 [gRPC](https://grpc.io/)의 장점(타입 안전성, 코드 생성)을 가져오면서도 HTTP/1.1을 지원해 React Native에서도 사용할 수 있다.\n\n## 왜 Connect RPC인가?\n\n### REST API의 문제점\n\n기존에는 [axios](https://axios-http.com/)로 REST API를 호출하고, 응답 타입을 수동으로 정의했다.\n\n```typescript\n// 수동으로 작성한 타입\ninterface ProfileResponse {\n  profile: {\n    userId: number;\n    nickname: string;\n    // ... 30개 이상의 필드\n  };\n}\n\n// API 호출\nconst response = await axios.get<ProfileResponse>('/profiles/me');\n```\n\n이 방식은 종종 이런 문제를 야기할 수 있다.\n\n1. **(그럴 일은 절대 없어야 하지만)백엔드가 API를 일방적으로 변경하면 프론트엔드는 런타임 에러가 나서야 안다**\n2. **타입 정의가 실제 API와 달라져도 TypeScript는 모른다**\n3. **필드 하나 추가될 때마다 타입 정의를 찾아서 수정해야 한다**\n\n### Connect RPC의 장점\n\nConnect RPC는 [Protobuf](https://protobuf.dev/) 스키마를 공유하고 코드를 자동 생성한다.\n\n```protobuf\n// proto 파일 (백엔드와 공유)\nmessage Profile {\n  int64 user_id = 1;\n  optional string nickname = 2;\n  // ...\n}\n\nservice ProfileService {\n  rpc GetMyProfile(GetMyProfileRequest) returns (GetMyProfileResponse);\n}\n```\n\n이 스키마에서 TypeScript 타입과 클라이언트 코드가 자동 생성되므로 아래와 같은 효과를 볼 수 있다.\n\n1. **백엔드가 스키마를 바꾸면 프론트엔드의 타입이 컴파일 타임에 깨진다**\n2. **타입 정의가 항상 실제 API와 일치한다**\n3. **proto 파일만 받으면 코드 생성으로 모든 게 업데이트된다**\n\n## 1. Protobuf Repository 추가\n\n백엔드와 proto 파일을 공유하기 위해 별도 저장소를 만들고 [git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules)로 관리하기로 했다.\n\n```bash\n# proto repository를 submodule로 추가\ngit submodule add git@github.com:your-org/myapp-proto.git proto\n\n# 폴더 구조\nproto/\n  ├── myapp/\n  │   └── v1/\n  │       ├── auth.proto\n  │       ├── profile.proto\n  │       └── interest.proto\n  └── buf.yaml\n```\n\nproto 파일 예시\n\n```protobuf\n// myapp/v1/auth.proto\nsyntax = \"proto3\";\n\npackage myapp.v1;\n\nservice AuthService {\n  rpc RequestSignup(RequestSignupRequest) returns (RequestSignupResponse);\n  rpc VerifySignup(VerifySignupRequest) returns (VerifySignupResponse);\n  rpc GetMe(GetMeRequest) returns (GetMeResponse);\n}\n\nmessage RequestSignupRequest {\n  string email = 1;\n}\n\nmessage RequestSignupResponse {\n  string message = 1;\n}\n\nmessage VerifySignupRequest {\n  string email = 1;\n  string code = 2;\n}\n\nmessage VerifySignupResponse {\n  string access_token = 1;\n  string refresh_token = 2;\n}\n```\n\n## 2. 패키지 설치\n\nConnect RPC와 Protobuf 관련 패키지를 설치한다.\n\n```bash\n# 런타임 라이브러리\nyarn add @connectrpc/connect @connectrpc/connect-web @bufbuild/protobuf\n\n# 코드 생성 도구 (dev dependencies)\nyarn add -D @bufbuild/buf @bufbuild/protoc-gen-es @connectrpc/protoc-gen-connect-es\n```\n\n각 패키지의 역할\n\n- `@connectrpc/connect`: Connect RPC 핵심 라이브러리\n- `@connectrpc/connect-web`: HTTP/1.1 기반 transport (React Native 호환)\n- `@bufbuild/protobuf`: Protobuf 메시지 런타임\n- [`@bufbuild/buf`](https://buf.build/docs/introduction): 코드 생성 CLI\n- `@bufbuild/protoc-gen-es`: TypeScript 타입 생성 플러그인\n- `@connectrpc/protoc-gen-connect-es`: Connect 서비스 클라이언트 생성 플러그인\n\n## 3. buf 설정 및 코드 생성\n\n`buf.gen.yaml` 파일을 만들어 코드 생성 설정을 작성한다.\n\n```yaml\n# buf.gen.yaml\nversion: v2\ninputs:\n  - directory: proto\nplugins:\n  - local: protoc-gen-es\n    out: gen\n    opt:\n      - target=ts\n  - local: protoc-gen-connect-es\n    out: gen\n    opt:\n      - target=ts\n```\n\npackage.json에 코드 생성 스크립트를 추가한다.\n\n```json\n{\n  \"scripts\": {\n    \"generate\": \"buf generate\"\n  }\n}\n```\n\n코드를 생성한다.\n\n```bash\nyarn generate\n```\n\n이제 `gen/` 폴더에 TypeScript 코드가 자동 생성된다.\n\n```\ngen/\n  └── myapp/\n      └── v1/\n          ├── auth_pb.ts        # 메시지 타입\n          ├── auth_connect.ts   # 서비스 정의\n          ├── profile_pb.ts\n          ├── profile_connect.ts\n          └── ...\n```\n\n생성된 코드 예시\n\n```typescript\n// gen/myapp/v1/auth_pb.ts\nexport type VerifySignupRequest = Message<'myapp.v1.VerifySignupRequest'> & {\n  email: string;\n  code: string;\n};\n\nexport type VerifySignupResponse = Message<'myapp.v1.VerifySignupResponse'> & {\n  accessToken: string;\n  refreshToken: string;\n};\n```\n\n## 4. Metro 설정 (중요!)\n\nReact Native의 [Metro bundler](https://metrobundler.dev/)가 Connect 패키지의 [package exports](https://nodejs.org/api/packages.html#exports)를 인식하도록 설정해야 한다. 이 설정이 없으면 런타임 에러가 발생한다.\n\n```javascript\n// metro.config.js\nconst { getDefaultConfig } = require('expo/metro-config');\n\nconst config = getDefaultConfig(__dirname);\n\n// package exports 활성화 (필수!)\nconfig.resolver.unstable_enablePackageExports = true;\n\nmodule.exports = config;\n```\n\nConnect 패키지는 Node.js 스타일의 package exports를 사용하는데, React Native의 Metro bundler는 기본적으로 이를 지원하지 않기 때문이다.\n\n## 5. Transport 및 클라이언트 설정\n\nConnect 클라이언트를 설정한다.\n\n```typescript\n// api/transport.ts\nimport { createClient } from '@connectrpc/connect';\nimport { createConnectTransport } from '@connectrpc/connect-web';\n\nimport { AuthService } from '@/gen/myapp/v1/auth_pb';\nimport { ProfileService } from '@/gen/myapp/v1/profile_pb';\nimport { InterestService } from '@/gen/myapp/v1/interest_pb';\n\nimport { createAuthInterceptor, createLoggingInterceptor } from './interceptors';\n\nconst API_URL = process.env.EXPO_PUBLIC_SERVER_URL;\n\nif (!API_URL) {\n  throw new Error('EXPO_PUBLIC_SERVER_URL is not defined');\n}\n\nconst transport = createConnectTransport({\n  baseUrl: API_URL,\n  interceptors: [createLoggingInterceptor(), createAuthInterceptor()],\n});\n\nexport const authClient = createClient(AuthService, transport);\nexport const profileClient = createClient(ProfileService, transport);\nexport const interestClient = createClient(InterestService, transport);\n```\n\n## 6. 인터셉터 구현\n\n인증 토큰 주입과 에러 핸들링을 위한 인터셉터를 구현한다.\n\n```typescript\n// api/interceptors.ts\nimport type { Interceptor } from '@connectrpc/connect';\n\nimport { useAuthStore } from '@/stores/authStore';\n\nexport const createAuthInterceptor = (): Interceptor => next => async req => {\n  const token = useAuthStore.getState().accessToken;\n\n  if (token) {\n    req.header.set('Authorization', `Bearer ${token}`);\n  }\n\n  return await next(req);\n};\n\nexport const createLoggingInterceptor = (): Interceptor => next => async req => {\n  console.log(`[Connect] ${req.method.name}`, req.message);\n\n  const response = await next(req);\n\n  console.log(`[Connect] ${req.method.name} response`, response.message);\n\n  return response;\n};\n```\n\nConnect의 인터셉터는 axios의 인터셉터와 비슷하지만 더 type-safe하다. 요청과 응답에 대한 모든 정보가 타입으로 보장된다.\n\n## 7. 에러 핸들링\n\nConnect RPC에서는 두 가지 에러 처리 방식이 있다.\n\n1. **Network/Protocol 에러** - Connect의 기본 `ConnectError` (네트워크 장애, 인증 실패 등)\n2. **비즈니스 로직 에러** - Protobuf로 정의된 `Error` 메시지\n\n먼저 proto에 Error 메시지를 정의한다.\n\n```protobuf\n// proto/myapp/v1/common.proto\nmessage Error {\n  ErrorCode code = 1;\n  string message = 2;\n  map<string, string> details = 3;\n}\n\nenum ErrorCode {\n  ERROR_CODE_UNSPECIFIED = 0;\n  ERROR_CODE_PROFILE_NOT_FOUND = 1;\n  ERROR_CODE_AUTH_ERROR = 2;\n  ERROR_CODE_INVALID_TOKEN = 3;\n  // ...\n}\n```\n\n모든 응답은 `oneof result` 패턴을 사용한다.\n\n```protobuf\nmessage VerifySignupResponse {\n  oneof result {\n    VerifySignupSuccess success = 1;\n    Error error = 2;\n  }\n}\n\nmessage VerifySignupSuccess {\n  string access_token = 1;\n  string refresh_token = 2;\n}\n```\n\n이 패턴을 처리하기 위해 `unwrap()` 함수와 `ApplicationError` 클래스를 만든다.\n\n```typescript\n// api/connectError.ts\nimport { ConnectError } from '@connectrpc/connect';\n\nimport { Error as ProtoError, ErrorCode } from '@/gen/myapp/v1/common_pb';\n\n/**\n * 비즈니스 로직 에러\n * Proto에 정의된 Error 메시지를 래핑함\n */\nexport class ApplicationError extends Error {\n  code: ErrorCode;\n  details: { [key: string]: string };\n\n  constructor(code: ErrorCode, message: string, details: { [key: string]: string } = {}) {\n    super(message);\n    this.code = code;\n    this.details = details;\n    Object.setPrototypeOf(this, ApplicationError.prototype);\n  }\n\n  static fromProto(error: ProtoError): ApplicationError {\n    return new ApplicationError(error.code, error.message, error.details);\n  }\n}\n\n/**\n * oneof result에서 성공값을 추출하거나 에러를 throw\n */\nexport function unwrap<T>(response: {\n  result:\n    | { case: 'success'; value: T }\n    | { case: 'error'; value: ProtoError }\n    | { case: undefined };\n}): NonNullable<T> {\n  if (response.result.case === 'error') {\n    throw ApplicationError.fromProto(response.result.value);\n  }\n  if (response.result.case === 'success') {\n    return response.result.value as NonNullable<T>;\n  }\n  throw new ApplicationError(ErrorCode.INTERNAL, 'Unknown response result');\n}\n\n/**\n * ConnectError를 ApplicationError로 변환\n */\nexport const handleConnectError = (error: unknown): ApplicationError => {\n  if (error instanceof ApplicationError) {\n    return error;\n  }\n\n  if (error instanceof ConnectError) {\n    // 네트워크 에러 등을 SYSTEM_ERROR로 매핑\n    return new ApplicationError(ErrorCode.SYSTEM_ERROR, error.message);\n  }\n\n  if (error instanceof Error) {\n    return new ApplicationError(\n      ErrorCode.INTERNAL,\n      error.message || '알 수 없는 오류가 발생했습니다',\n    );\n  }\n\n  return new ApplicationError(ErrorCode.UNSPECIFIED, '알 수 없는 오류가 발생했습니다');\n};\n```\n\n### 백엔드 구현\n\n백엔드는 비즈니스 로직 에러를 Protobuf `Error` 메시지로 만든다. 이 방식을 사용하면 에러 코드가 proto enum으로 정의되어 백엔드-프론트엔드 간 타입 일치가 보장된다.\n\n```go\n// internal/response/errors.go\nfunc NewConnectError(code domain.ErrorCode, err error) *connect.Error {\n  connectErr := connect.NewError(toConnectCode(code), err)\n\n  // Protobuf Error 메시지 생성\n  protoErr := &duologuev1.Error{\n    Code:    domain.ToProtoErrorCode(code),\n    Message: err.Error(),\n    Details: make(map[string]string),\n  }\n\n  // Error를 Connect error detail로 추가\n  if detail, detailErr := connect.NewErrorDetail(protoErr); detailErr == nil {\n    connectErr.AddDetail(detail)\n  }\n\n  return connectErr\n}\n```\n\n### 인터셉터에서 에러 코드별 처리\n\n인터셉터에서 특정 에러 코드에 대한 공통 처리를 할 수 있다.\n\n```typescript\n// api/interceptors.ts\nexport const createAuthInterceptor = (): Interceptor => next => async req => {\n  const token = useAuthStore.getState().accessToken;\n  if (token) {\n    req.header.set('Authorization', `Bearer ${token}`);\n  }\n\n  try {\n    return await next(req);\n  } catch (error) {\n    if (error instanceof ApplicationError) {\n      // 프로필 없음 → 로그아웃 처리\n      if (error.code === ErrorCode.PROFILE_NOT_FOUND) {\n        useAuthStore.getState().clearAuth();\n        router.replace('/');\n        throw error;\n      }\n\n      // 인증 에러 → 토큰 갱신 시도\n      if (\n        error.code === ErrorCode.AUTH_ERROR ||\n        error.code === ErrorCode.AUTH_REQUIRED ||\n        error.code === ErrorCode.INVALID_TOKEN\n      ) {\n        const newToken = await tokenRefreshManager.refresh();\n        req.header.set('Authorization', `Bearer ${newToken}`);\n        return await next(req); // 재시도\n      }\n    }\n\n    throw error;\n  }\n};\n```\n\n이렇게 함으로써 이제 에러를 보다 편하게 다룰 수 있다.\n\n1. **타입 안전한 에러 처리** - ErrorCode enum으로 가능한 에러를 컴파일 타임에 알 수 있음\n2. **중앙화된 에러 처리** - 인터셉터에서 공통 에러 로직 처리\n3. **명시적인 에러 흐름** - oneof를 통해 성공/실패가 proto 레벨에서 명확히 구분됨\n\n## 8. API 레이어 마이그레이션\n\n이제 기존 axios 기반 API를 Connect로 교체한다.\n\n### Before (axios)\n\n```typescript\n// api/auth.ts (before)\nimport { apiClient } from './client';\n\ninterface VerifySignupRequest {\n  email: string;\n  code: string;\n}\n\ninterface TokenResponse {\n  access_token: string;\n  refresh_token: string;\n}\n\nexport const authApi = {\n  verifySignup: async (email: string, code: string): Promise<TokenResponse> => {\n    const response = await apiClient.post<TokenResponse>('/auth/verify-signup', {\n      email,\n      code,\n    });\n    return response.data;\n  },\n};\n```\n\n### After (Connect)\n\n```typescript\n// api/auth.ts (after)\nimport { create } from '@bufbuild/protobuf';\n\nimport { VerifySignupRequestSchema } from '@/gen/myapp/v1/auth_pb';\n\nimport { handleConnectError } from './connectError';\nimport { authClient } from './transport';\n\ninterface TokenResponse {\n  accessToken: string;\n  refreshToken: string;\n}\n\nexport const authApi = {\n  verifySignup: async (email: string, code: string): Promise<TokenResponse> => {\n    try {\n      const request = create(VerifySignupRequestSchema, { email, code });\n      const response = await authClient.verifySignup(request);\n      const result = unwrap(response); // oneof result 처리\n      return {\n        accessToken: result.accessToken,\n        refreshToken: result.refreshToken,\n      };\n    } catch (error) {\n      throw handleConnectError(error);\n    }\n  },\n};\n```\n\n변경된 점은 다음과 같다.\n\n1. **타입을 수동으로 정의하지 않는다** - proto에서 자동 생성됨\n2. **URL 경로를 하드코딩하지 않는다** - 서비스 정의에 포함됨\n3. **create()로 요청 메시지를 생성한다** - 타입 안전성 보장\n\n### Profile API 예시\n\n```typescript\n// api/profile.ts\nimport { create } from '@bufbuild/protobuf';\n\nimport { GetMyProfileRequestSchema, UpdateMyProfileRequestSchema } from '@/gen/myapp/v1/profile_pb';\n\nimport { handleConnectError } from './connectError';\nimport { profileClient } from './transport';\n\nexport const profileApi = {\n  getMe: async (): Promise<ProfileMe> => {\n    try {\n      const request = create(GetMyProfileRequestSchema, {});\n      const response = await profileClient.getMyProfile(request);\n      const result = unwrap(response); // oneof result 처리\n\n      return mapProfile(result.profile);\n    } catch (error) {\n      throw handleConnectError(error);\n    }\n  },\n\n  updateMe: async (data: UpdateProfileData): Promise<ProfileMe> => {\n    try {\n      const request = create(UpdateMyProfileRequestSchema, {\n        nickname: data.nickname,\n        gender: data.gender,\n        region: data.region,\n        shortBio: data.shortBio,\n        profileImageUrl: data.profileImageUrl,\n        interestIds: data.interestIds?.map(id => BigInt(id)) ?? [],\n      });\n\n      const response = await profileClient.updateMyProfile(request);\n      const result = unwrap(response); // oneof result 처리\n\n      return mapProfile(result.profile);\n    } catch (error) {\n      throw handleConnectError(error);\n    }\n  },\n};\n```\n\n## 9. React Query 훅은 그대로\n\n[React Query](https://tanstack.com/query/latest) 훅은 API 함수만 호출하므로 수정할 필요가 없다.\n\n```typescript\n// queries/useMutationAuth.ts\nexport const useVerifySignup = () => {\n  return useMutation({\n    mutationFn: ({ email, code }: VerifySignupParams) => authApi.verifySignup(email, code),\n    onSuccess: data => {\n      setTokens(data.accessToken, data.refreshToken);\n    },\n  });\n};\n```\n\nAPI 레이어만 교체했으므로 컴포넌트 코드는 전혀 수정하지 않아도 된다.\n\n## 10. axios 제거\n\n마이그레이션이 완료되면 axios를 제거한다.\n\n```bash\nyarn remove axios\n```\n\n기존에 axios를 사용하던 파일들도 삭제한다.\n\n```bash\nrm api/client.ts  # axios 클라이언트\n```\n\n## 결과\n\n### 타입 안전성 확보\n\n이제 백엔드가 API를 변경하면 프론트엔드가 **컴파일 타임에** 에러가 발생한다.\n\n```typescript\n// proto에서 nickname 필드가 제거되면\nconst profile = await profileApi.getMe();\nconsole.log(profile.nickname); // ❌ TypeScript 에러: 'nickname' does not exist\n```\n\n### 개발 경험 개선\n\n1. **자동 완성이 정확하다** - proto에 정의된 필드만 자동 완성됨\n2. **리팩토링이 안전하다** - 필드명을 바꾸면 사용하는 모든 곳에서 에러 발생\n3. **문서가 필요 없다** - proto 파일이 곧 API 명세서\n\n### 유지보수 비용 감소\n\n- 타입 정의를 수동으로 관리할 필요 없음\n- snake_case ↔ camelCase 변환 코드 불필요\n- API 변경 시 영향받는 코드를 TypeScript가 알려줌\n\n## Binary vs JSON\n\nConnect RPC는 binary(Protobuf)와 JSON 두 가지 포맷을 지원한다. `createConnectTransport`는 기본적으로 binary 포맷을 사용하므로, 별도 설정 없이도 binary의 이점을 누릴 수 있다.\n\n- **Binary (기본값)** - 더 작은 페이로드, 더 빠른 직렬화/역직렬화\n- **JSON** - 디버깅이 쉬움 (네트워크 탭에서 내용 확인 가능)\n\nProto 스키마의 타입 안전성을 유지하면서 실제 통신 데이터 포맷은 선택할 수 있다는 것이 Connect RPC의 큰 장점이다. 개발 환경에서 디버깅이 필요하다면 JSON으로, 프로덕션에서는 Binary로 전환하는 것도 가능하다.\n\n```typescript\nconst transport = createConnectTransport({\n  baseUrl: API_URL,\n  useBinaryFormat: false, // JSON 사용 (디버깅 시 편리)\n  // useBinaryFormat을 생략하면 기본값인 true(binary)가 적용됨\n});\n```\n\n## 주의사항\n\n### 1. Metro 설정 필수\n\n`unstable_enablePackageExports`를 활성화하지 않으면 런타임 에러가 발생한다. 이 설정을 빠뜨리면 앱이 제대로 실행되지 않는다.\n\n### 2. Streaming은 미지원\n\nConnect RPC는 [Unary RPC](https://grpc.io/docs/what-is-grpc/core-concepts/#unary-rpc)만 지원한다. [Server Streaming](https://grpc.io/docs/what-is-grpc/core-concepts/#server-streaming-rpc)이나 [Bidirectional Streaming](https://grpc.io/docs/what-is-grpc/core-concepts/#bidirectional-streaming-rpc)은 React Native에서 작동하지 않는다.\n\n### 3. 코드 생성 타이밍\n\nproto 파일이 변경되면 `yarn generate`를 다시 실행해야 한다. submodule을 업데이트할 때마다 실행하는 것을 잊지 말자.\n\n```bash\n# proto submodule 업데이트 후\ngit submodule update --remote proto\nyarn generate\n```\n\nproto 파일은 Protobuf의 네이밍 규칙에 따라 snake_case를 사용하지만, Connect는 코드 생성 시 자동으로 TypeScript의 camelCase로 변환해준다.\n\n## 마무리\n\nREST API에서 Connect RPC로 마이그레이션하면서 가장 만족스러운 점은 **타입 안전성**이다. 백엔드가 API를 변경하면 프론트엔드가 런타임이 아닌 컴파일 타임에 깨지므로, 배포 전에 문제를 발견할 수 있다.\n\n수동으로 타입을 정의하던 시간을 아낄 수 있고, proto 파일만 보면 API 명세를 정확히 알 수 있어 문서를 별도로 관리할 필요도 없어졌다.\n\n백엔드와 프론트엔드가 상호완결성을 가지는 서비스 프로덕트라면 gRPC 도입을 고려 해보는 것도 나쁘지 않은 것 같다.\n"}}]]}]],null],"segment":"__PAGE__?{\"tag\":\"React Native\"}"},"styles":[]}],"segment":["tag","React%20Native","d"]},"styles":[]}],"segment":"tags"},"styles":[]}],"params":{}}],null]
3:[[["$","meta",null,{"charSet":"utf-8"}],null,null,null,null,null,null,null,null,null,null,["$","meta",null,{"name":"viewport","content":"width=device-width, initial-scale=1"}],null,null,null,null,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,null,null,null,[null,[["$","link",null,{"rel":"icon","href":"/icon.svg?43070ac23468c58b","type":"image/svg+xml","sizes":"32x32"}]],[],null]]
