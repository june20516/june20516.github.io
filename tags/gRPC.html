<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><link rel="stylesheet" href="/_next/static/css/0ad9df217a839d7d.css" data-precedence="next"/><link rel="preload" as="style" href="https://cdn.jsdelivr.net/gh/june20516/orbithall@widget/v1.1.1/static/embed.css"/><link rel="preload" as="script" href="https://www.googletagmanager.com/gtag/js?id=G-Q587R5F0YL"/><link rel="preload" as="script" href="https://cdn.jsdelivr.net/gh/june20516/orbithall@widget/v1.1.1/static/embed.js"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="/icon.svg?43070ac23468c58b" type="image/svg+xml" sizes="32x32"/><meta name="google-site-verification" content="i0Iq4sKjYlVS7Q9gq9KkCPl4hdoADOzOsTyFnCV24Os"/><style data-emotion="css-global 1mv6lxk">:root{--mui-palette-primary-main:#171717;--mui-palette-secondary-main:#737373;--mui-palette-info-main:#3b82f6;--mui-palette-error-main:#ef4444;--mui-palette-background-default:#ffffff;--mui-palette-action-active:#171717;--mui-palette-action-disabled:#d4d4d4;--mui-palette-text-primary:#171717;--mui-palette-text-secondary:#737373;--mui-palette-text-disabled:#d4d4d4;--mui-palette-divider:#e5e5e5;--mui-typography-fontFamily:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/june20516/orbithall@widget/v1.1.1/static/embed.css"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" noModule=""></script></head><style data-emotion="css k186h9">.css-k186h9{min-height:100vh;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;background-color:#ffffff;}</style><body class="MuiBox-root css-k186h9"><style data-emotion="css 1vseziz">.css-1vseziz{position:-webkit-sticky;position:sticky;top:0;z-index:1000;border-bottom:1px solid #e5e5e5;background-color:#ffffff;overflow:hidden;}.css-1vseziz::before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background-image:url(/assets/images/default-thumbnail.jpg);-webkit-background-size:120%;background-size:120%;-webkit-background-position:center;background-position:center;opacity:1;z-index:0;-webkit-animation:headerBackgroundFloat 300s ease-in-out infinite;animation:headerBackgroundFloat 300s ease-in-out infinite;}@-webkit-keyframes headerBackgroundFloat{0%,100%{-webkit-background-position:center top;background-position:center top;}50%{-webkit-background-position:center bottom;background-position:center bottom;}}@keyframes headerBackgroundFloat{0%,100%{-webkit-background-position:center top;background-position:center top;}50%{-webkit-background-position:center bottom;background-position:center bottom;}}.css-1vseziz::after{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background-color:#ffffff;opacity:0.65;z-index:1;}</style><header class="MuiBox-root css-1vseziz"><style data-emotion="css cam08f">.css-cam08f{position:relative;z-index:2;max-width:1024px;margin-left:auto;margin-right:auto;padding-top:16px;padding-bottom:16px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;gap:32px;}@media (min-width:0px){.css-cam08f{padding-left:24px;padding-right:24px;}}@media (min-width:640px){.css-cam08f{padding-left:32px;padding-right:32px;}}@media (min-width:768px){.css-cam08f{padding-left:48px;padding-right:48px;}}</style><div class="MuiBox-root css-cam08f"><a style="text-decoration:none" href="/"><style data-emotion="css 120nera">.css-120nera{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:12px;}</style><div class="MuiBox-root css-120nera"><svg width="24" height="24" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="32" height="32" rx="6" fill="url(#gradient)"></rect><text x="16" y="22" font-family="system-ui, -apple-system, sans-serif" font-size="18" font-weight="700" fill="white" text-anchor="middle" letter-spacing="-0.02em">B</text><defs><linearGradient id="gradient" x1="0" y1="0" x2="32" y2="32" gradientUnits="userSpaceOnUse"><stop offset="0%" stop-color="#667eea"></stop><stop offset="100%" stop-color="#764ba2"></stop></linearGradient></defs></svg><style data-emotion="css 1bye4no">.css-1bye4no{margin:0;font-size:1.125rem;font-weight:600;line-height:1.5;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#171717;font-weight:600;letter-spacing:-0.01em;-webkit-transition:color 0.2s ease;transition:color 0.2s ease;}.css-1bye4no:hover{color:#737373;}</style><h6 class="MuiTypography-root MuiTypography-h6 css-1bye4no">Codeverse</h6></div></a><style data-emotion="css 1xiah1o">.css-1xiah1o{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}@media (min-width:0px){.css-1xiah1o{gap:16px;}}@media (min-width:640px){.css-1xiah1o{gap:24px;}}</style><nav class="MuiBox-root css-1xiah1o"><a style="text-decoration:none" href="/posts"><style data-emotion="css 1t5x1u">.css-1t5x1u{margin:0;font-size:0.875rem;line-height:1.6;font-weight:400;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#737373;font-weight:400;font-size:0.875rem;-webkit-transition:color 0.2s ease;transition:color 0.2s ease;}.css-1t5x1u:hover{color:#171717;}</style><p class="MuiTypography-root MuiTypography-body2 css-1t5x1u">Posts</p></a><a style="text-decoration:none" href="/tags"><style data-emotion="css 4nm0tw">.css-4nm0tw{margin:0;font-size:0.875rem;line-height:1.6;font-weight:400;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#171717;font-weight:500;font-size:0.875rem;-webkit-transition:color 0.2s ease;transition:color 0.2s ease;}.css-4nm0tw:hover{color:#171717;}</style><p class="MuiTypography-root MuiTypography-body2 css-4nm0tw">Tags</p></a><a style="text-decoration:none" href="/lab"><p class="MuiTypography-root MuiTypography-body2 css-1t5x1u">Lab</p></a><a style="text-decoration:none" href="/about"><p class="MuiTypography-root MuiTypography-body2 css-1t5x1u">About</p></a></nav></div></header><style data-emotion="css 6rhssw">.css-6rhssw{-webkit-flex:1;-ms-flex:1;flex:1;width:100%;max-width:1024px;margin-left:auto;margin-right:auto;padding-top:48px;padding-bottom:48px;}@media (min-width:0px){.css-6rhssw{padding-left:24px;padding-right:24px;}}@media (min-width:640px){.css-6rhssw{padding-left:32px;padding-right:32px;}}@media (min-width:768px){.css-6rhssw{padding-left:48px;padding-right:48px;}}</style><main class="MuiBox-root css-6rhssw"><style data-emotion="css k008qs">.css-k008qs{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}</style><div class="MuiBox-root css-k008qs"><style data-emotion="css 30jlqd">.css-30jlqd{padding-left:16px;padding-right:16px;margin-right:8px;border-radius:8px;background-color:whitesmoke;}</style><code class="MuiBox-root css-30jlqd"><style data-emotion="css 1iihwok">.css-1iihwok{margin:0;font-size:1rem;line-height:1.7;font-weight:400;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#171717;}</style><span class="MuiTypography-root MuiTypography-body1 css-1iihwok">gRPC</span></code><style data-emotion="css 8mr3c0">.css-8mr3c0{margin:0;font-size:1rem;line-height:1.7;font-weight:400;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#171717;}</style><p class="MuiTypography-root MuiTypography-body1 css-8mr3c0">가 태그된 글 목록 -</p><style data-emotion="css mb6o02">.css-mb6o02{margin:0;font-size:1rem;line-height:1.7;font-weight:400;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#171717;font-style:italic;padding-left:0.3125rem;padding-right:0.3125rem;}</style><p class="MuiTypography-root MuiTypography-body1 css-mb6o02">1</p><p class="MuiTypography-root MuiTypography-body1 css-8mr3c0">개</p></div><ol><a style="text-decoration:none" href="posts/react-native-connect-rpc-migration"><style data-emotion="css 157568j">.css-157568j{padding-top:24px;padding-bottom:24px;border-bottom:1px solid #e5e5e5;-webkit-transition:all 0.2s ease;transition:all 0.2s ease;}.css-157568j:hover{border-bottom-color:#a3a3a3;}.css-157568j:hover .post-title{color:#171717;}</style><div class="MuiBox-root css-157568j"><style data-emotion="css 178uv34">.css-178uv34{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:24px;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;}</style><div class="MuiBox-root css-178uv34"><style data-emotion="css z8l7kn">.css-z8l7kn{border-radius:16px;overflow:hidden;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;background-color:#f5f5f5;}@media (min-width:0px){.css-z8l7kn{width:80px;height:80px;}}@media (min-width:640px){.css-z8l7kn{width:120px;height:120px;}}</style><div class="MuiBox-root css-z8l7kn"><img src="/assets/images/posts/thumbnails/react-native-connect-rpc-migration.png" alt="React Native에서 REST API를 Connect RPC로 마이그레이션하기" style="width:100%;height:100%;object-fit:cover"/></div><style data-emotion="css 1fjtzvx">.css-1fjtzvx{-webkit-flex:1;-ms-flex:1;flex:1;min-width:0;}</style><div class="MuiBox-root css-1fjtzvx"><style data-emotion="css w8q7jp">.css-w8q7jp{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-align-items:baseline;-webkit-box-align:baseline;-ms-flex-align:baseline;align-items:baseline;gap:16px;margin-bottom:8px;}</style><div class="MuiBox-root css-w8q7jp"><style data-emotion="css b0udfb">.css-b0udfb{margin:0;font-size:1.125rem;font-weight:600;line-height:1.5;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#171717;font-weight:500;-webkit-transition:color 0.2s ease;transition:color 0.2s ease;}@media (min-width:0px){.css-b0udfb{font-size:1.0625rem;}}@media (min-width:640px){.css-b0udfb{font-size:1.125rem;}}</style><h6 class="MuiTypography-root MuiTypography-h6 post-title css-b0udfb">React Native에서 REST API를 Connect RPC로 마이그레이션하기</h6><style data-emotion="css 19o4s0j">.css-19o4s0j{margin:0;font-size:0.75rem;line-height:1.5;font-weight:400;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#a3a3a3;white-space:nowrap;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}@media (min-width:0px){.css-19o4s0j{display:none;}}@media (min-width:640px){.css-19o4s0j{display:block;}}</style><span class="MuiTypography-root MuiTypography-caption css-19o4s0j">2026/01/05</span></div><style data-emotion="css 104igq0">.css-104igq0{margin:0;font-size:0.875rem;line-height:1.6;font-weight:400;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#737373;line-height:1.6;}@media (min-width:0px){.css-104igq0{margin-bottom:8px;}}@media (min-width:640px){.css-104igq0{margin-bottom:0px;}}</style><p class="MuiTypography-root MuiTypography-body2 css-104igq0">axios를 버리고 타입 안전한 gRPC 세상으로</p><style data-emotion="css sr5pox">.css-sr5pox{margin:0;font-size:0.75rem;line-height:1.5;font-weight:400;font-family:Pretendard,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;color:#a3a3a3;}@media (min-width:0px){.css-sr5pox{display:block;}}@media (min-width:640px){.css-sr5pox{display:none;}}</style><span class="MuiTypography-root MuiTypography-caption css-sr5pox">2026/01/05</span></div></div></div></a></ol></main><!--$!--><template data-dgst="NEXT_DYNAMIC_NO_SSR_CODE"></template><!--/$--><script src="/_next/static/chunks/webpack-932dee968bc237b7.js" async=""></script><script src="/_next/static/chunks/2443530c-0538301a504b83cf.js" async=""></script><script src="/_next/static/chunks/488-c0b34e96c35b33f7.js" async=""></script><script src="/_next/static/chunks/main-app-98d28d7655df5891.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/0ad9df217a839d7d.css\",{\"as\":\"style\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:I{\"id\":\"8827\",\"chunks\":[\"272:static/chunks/webpack-932dee968bc237b7.js\",\"667:static/chunks/2443530c-0538301a504b83cf.js\",\"488:static/chunks/488-c0b34e96c35b33f7.js\"],\"name\":\"\",\"async\":false}\n5:I{\"id\":\"9126\",\"chunks\":[\"272:static/chunks/webpack-932dee968bc237b7.js\",\"667:static/chunks/2443530c-0538301a504b83cf.js\",\"488:static/chunks/488-c0b34e96c35b33f7.js\"],\"name\":\"\",\"async\":false}\n6:I{\"id\":\"6886\",\"chunks\":[\"771:static/chunks/771-4a62562d40204820.js\",\"846:static/chunks/846-5374114718c3ba3f.js\",\"218:static/"])</script><script>self.__next_f.push([1,"chunks/218-24e2ed3a86df3181.js\",\"185:static/chunks/app/layout-1a9b501ae2e54936.js\"],\"name\":\"\",\"async\":false}\n8:I{\"id\":\"4463\",\"chunks\":[\"272:static/chunks/webpack-932dee968bc237b7.js\",\"667:static/chunks/2443530c-0538301a504b83cf.js\",\"488:static/chunks/488-c0b34e96c35b33f7.js\"],\"name\":\"\",\"async\":false}\n9:I{\"id\":\"1010\",\"chunks\":[\"272:static/chunks/webpack-932dee968bc237b7.js\",\"667:static/chunks/2443530c-0538301a504b83cf.js\",\"488:static/chunks/488-c0b34e96c35b33f7.js\"],\"name\":\"\",\"async\":false}\na:I{\"id\":\"5568\",\""])</script><script>self.__next_f.push([1,"chunks\":[\"771:static/chunks/771-4a62562d40204820.js\",\"846:static/chunks/846-5374114718c3ba3f.js\",\"605:static/chunks/app/tags/[tag]/page-e744f023ced56cc6.js\"],\"name\":\"\",\"async\":false}\nb:I{\"id\":\"6640\",\"chunks\":[\"771:static/chunks/771-4a62562d40204820.js\",\"846:static/chunks/846-5374114718c3ba3f.js\",\"605:static/chunks/app/tags/[tag]/page-e744f023ced56cc6.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ad9df217a839d7d.css\",\"precedence\":\"next\"}]],[\"$\",\"$L3\",null,{\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/tags/gRPC\",\"initialTree\":[\"\",{\"children\":[\"tags\",{\"children\":[[\"tag\",\"gRPC\",\"d\"],{\"children\":[\"__PAGE__?{\\\"tag\\\":\\\"gRPC\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[\"$L4\",null],\"globalErrorComponent\":\"$5\",\"notFound\":[\"$\",\"$L6\",null,{\"params\":{},\"children\":[\"$L7\",\"$undefined\",[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]]}],\"asNotFound\":false,\"children\":[[\"$\",\"$L6\",null,{\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"tags\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"tags\",\"children\",[\"tag\",\"gRPC\",\"d\"],\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[[[\"$\",\"$La\",null,{\"tag\":\"gRPC\",\"count\":1}],[\"$\",\"ol\",null,{\"children\":[[\"$\",\"$Lb\",\"0\",{\"post\":{\"slug\":\"react-native-connect-rpc-migration\",\"meta\":{\"title\":\"React Native에서 REST API를 Connect RPC로 마이그레이션하기\",\"description\":\"axios를 버리고 타입 안전한 gRPC 세상으로\",\"date\":\"2026/01/05\",\"tags\":[\"React Native\",\"Connect RPC\",\"Protobuf\",\"gRPC\",\"TypeScript\"],\"categories\":[\"dev\",\"architecture\"],\"thumbnail\":\"assets/images/posts/thumbnails/react-native-connect-rpc-migration.png\"},\"content\":\"\\n# React Native에서 REST API를 Connect RPC로 마이그레이션하기\\n\\nAPI 문서의 중요함은 웹 개발자들 사이에서 말하면 입아플 정도로 널리 공감되는 주제이다. 이를 위해 많은 도구들이 존재하고 다양한 노력들이 이루어졌다.\\n나는 최근에 프로젝트를 진행하며 백엔드 입장에서 문서를 제공해야 했었고, 가져가기로 한 기술 스택에서 이 문서화 도구의 지원이 빈약함을 알게 되었다. 그래서 조금 더 많은 수작업이 필요해졌는데, 갑자기 회의감이 들었다. 코드와 코드의 대화 사이에 들어가는 사람의 손길, 이 헐거움이 어색하게 느껴졌다.\\n이 문제를 근본적으로 해결하기 위해 REST API를 버리고 [Connect RPC](https://connectrpc.com/)로 전환하기로 결정했다. Connect RPC는 [gRPC](https://grpc.io/)의 장점(타입 안전성, 코드 생성)을 가져오면서도 HTTP/1.1을 지원해 React Native에서도 사용할 수 있다.\\n\\n## 왜 Connect RPC인가?\\n\\n### REST API의 문제점\\n\\n기존에는 [axios](https://axios-http.com/)로 REST API를 호출하고, 응답 타입을 수동으로 정의했다.\\n\\n```typescript\\n// 수동으로 작성한 타입\\ninterface ProfileResponse {\\n  profile: {\\n    userId: number;\\n    nickname: string;\\n    // ... 30개 이상의 필드\\n  };\\n}\\n\\n// API 호출\\nconst response = await axios.get\u003cProfileResponse\u003e('/profiles/me');\\n```\\n\\n이 방식의 문제는:\\n\\n1. **(그럴 일은 절대 없어야 하지만)백엔드가 API를 일방적으로 변경하면 프론트엔드는 런타임 에러가 나서야 안다**\\n2. **타입 정의가 실제 API와 달라져도 TypeScript는 모른다**\\n3. **필드 하나 추가될 때마다 타입 정의를 찾아서 수정해야 한다**\\n\\n### Connect RPC의 장점\\n\\nConnect RPC는 [Protobuf](https://protobuf.dev/) 스키마를 공유하고 코드를 자동 생성한다.\\n\\n```protobuf\\n// proto 파일 (백엔드와 공유)\\nmessage Profile {\\n  int64 user_id = 1;\\n  optional string nickname = 2;\\n  // ...\\n}\\n\\nservice ProfileService {\\n  rpc GetMyProfile(GetMyProfileRequest) returns (GetMyProfileResponse);\\n}\\n```\\n\\n이 스키마에서 TypeScript 타입과 클라이언트 코드가 자동 생성되므로:\\n\\n1. **백엔드가 스키마를 바꾸면 프론트엔드의 타입이 컴파일 타임에 깨진다**\\n2. **타입 정의가 항상 실제 API와 일치한다**\\n3. **proto 파일만 받으면 코드 생성으로 모든 게 업데이트된다**\\n\\n## 1. Protobuf Repository 추가\\n\\n백엔드와 proto 파일을 공유하기 위해 별도 저장소를 만들고 [git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules)로 관리하기로 했다.\\n\\n```bash\\n# proto repository를 submodule로 추가\\ngit submodule add git@github.com:your-org/myapp-proto.git proto\\n\\n# 폴더 구조\\nproto/\\n  ├── myapp/\\n  │   └── v1/\\n  │       ├── auth.proto\\n  │       ├── profile.proto\\n  │       └── interest.proto\\n  └── buf.yaml\\n```\\n\\nproto 파일 예시:\\n\\n```protobuf\\n// myapp/v1/auth.proto\\nsyntax = \\\"proto3\\\";\\n\\npackage myapp.v1;\\n\\nservice AuthService {\\n  rpc RequestSignup(RequestSignupRequest) returns (RequestSignupResponse);\\n  rpc VerifySignup(VerifySignupRequest) returns (VerifySignupResponse);\\n  rpc GetMe(GetMeRequest) returns (GetMeResponse);\\n}\\n\\nmessage RequestSignupRequest {\\n  string email = 1;\\n}\\n\\nmessage RequestSignupResponse {\\n  string message = 1;\\n}\\n\\nmessage VerifySignupRequest {\\n  string email = 1;\\n  string code = 2;\\n}\\n\\nmessage VerifySignupResponse {\\n  string access_token = 1;\\n  string refresh_token = 2;\\n}\\n```\\n\\n## 2. 패키지 설치\\n\\nConnect RPC와 Protobuf 관련 패키지를 설치한다.\\n\\n```bash\\n# 런타임 라이브러리\\nyarn add @connectrpc/connect @connectrpc/connect-web @bufbuild/protobuf\\n\\n# 코드 생성 도구 (dev dependencies)\\nyarn add -D @bufbuild/buf @bufbuild/protoc-gen-es @connectrpc/protoc-gen-connect-es\\n```\\n\\n각 패키지의 역할:\\n\\n- `@connectrpc/connect`: Connect RPC 핵심 라이브러리\\n- `@connectrpc/connect-web`: HTTP/1.1 기반 transport (React Native 호환)\\n- `@bufbuild/protobuf`: Protobuf 메시지 런타임\\n- [`@bufbuild/buf`](https://buf.build/docs/introduction): 코드 생성 CLI\\n- `@bufbuild/protoc-gen-es`: TypeScript 타입 생성 플러그인\\n- `@connectrpc/protoc-gen-connect-es`: Connect 서비스 클라이언트 생성 플러그인\\n\\n## 3. buf 설정 및 코드 생성\\n\\n`buf.gen.yaml` 파일을 만들어 코드 생성 설정을 작성한다.\\n\\n```yaml\\n# buf.gen.yaml\\nversion: v2\\ninputs:\\n  - directory: proto\\nplugins:\\n  - local: protoc-gen-es\\n    out: gen\\n    opt:\\n      - target=ts\\n  - local: protoc-gen-connect-es\\n    out: gen\\n    opt:\\n      - target=ts\\n```\\n\\npackage.json에 코드 생성 스크립트를 추가한다.\\n\\n```json\\n{\\n  \\\"scripts\\\": {\\n    \\\"generate\\\": \\\"buf generate\\\"\\n  }\\n}\\n```\\n\\n코드를 생성한다.\\n\\n```bash\\nyarn generate\\n```\\n\\n이제 `gen/` 폴더에 TypeScript 코드가 자동 생성된다:\\n\\n```\\ngen/\\n  └── myapp/\\n      └── v1/\\n          ├── auth_pb.ts        # 메시지 타입\\n          ├── auth_connect.ts   # 서비스 정의\\n          ├── profile_pb.ts\\n          ├── profile_connect.ts\\n          └── ...\\n```\\n\\n생성된 코드 예시:\\n\\n```typescript\\n// gen/myapp/v1/auth_pb.ts\\nexport type VerifySignupRequest = Message\u003c'myapp.v1.VerifySignupRequest'\u003e \u0026 {\\n  email: string;\\n  code: string;\\n};\\n\\nexport type VerifySignupResponse = Message\u003c'myapp.v1.VerifySignupResponse'\u003e \u0026 {\\n  accessToken: string;\\n  refreshToken: string;\\n};\\n```\\n\\n## 4. Metro 설정 (중요!)\\n\\nReact Native의 [Metro bundler](https://metrobundler.dev/)가 Connect 패키지의 [package exports](https://nodejs.org/api/packages.html#exports)를 인식하도록 설정해야 한다. 이 설정이 없으면 런타임 에러가 발생한다.\\n\\n```javascript\\n// metro.config.js\\nconst { getDefaultConfig } = require('expo/metro-config');\\n\\nconst config = getDefaultConfig(__dirname);\\n\\n// package exports 활성화 (필수!)\\nconfig.resolver.unstable_enablePackageExports = true;\\n\\nmodule.exports = config;\\n```\\n\\nConnect 패키지는 Node.js 스타일의 package exports를 사용하는데, React Native의 Metro bundler는 기본적으로 이를 지원하지 않기 때문이다.\\n\\n## 5. Transport 및 클라이언트 설정\\n\\nConnect 클라이언트를 설정한다.\\n\\n```typescript\\n// api/transport.ts\\nimport { createClient } from '@connectrpc/connect';\\nimport { createConnectTransport } from '@connectrpc/connect-web';\\n\\nimport { AuthService } from '@/gen/myapp/v1/auth_pb';\\nimport { ProfileService } from '@/gen/myapp/v1/profile_pb';\\nimport { InterestService } from '@/gen/myapp/v1/interest_pb';\\n\\nimport { createAuthInterceptor, createLoggingInterceptor } from './interceptors';\\n\\nconst API_URL = process.env.EXPO_PUBLIC_SERVER_URL;\\n\\nif (!API_URL) {\\n  throw new Error('EXPO_PUBLIC_SERVER_URL is not defined');\\n}\\n\\nconst transport = createConnectTransport({\\n  baseUrl: API_URL,\\n  interceptors: [createLoggingInterceptor(), createAuthInterceptor()],\\n});\\n\\nexport const authClient = createClient(AuthService, transport);\\nexport const profileClient = createClient(ProfileService, transport);\\nexport const interestClient = createClient(InterestService, transport);\\n```\\n\\n## 6. 인터셉터 구현\\n\\n인증 토큰 주입과 에러 핸들링을 위한 인터셉터를 구현한다.\\n\\n```typescript\\n// api/interceptors.ts\\nimport type { Interceptor } from '@connectrpc/connect';\\n\\nimport { useAuthStore } from '@/stores/authStore';\\n\\nexport const createAuthInterceptor = (): Interceptor =\u003e next =\u003e async req =\u003e {\\n  const token = useAuthStore.getState().accessToken;\\n\\n  if (token) {\\n    req.header.set('Authorization', `Bearer ${token}`);\\n  }\\n\\n  return await next(req);\\n};\\n\\nexport const createLoggingInterceptor = (): Interceptor =\u003e next =\u003e async req =\u003e {\\n  console.log(`[Connect] ${req.method.name}`, req.message);\\n\\n  const response = await next(req);\\n\\n  console.log(`[Connect] ${req.method.name} response`, response.message);\\n\\n  return response;\\n};\\n```\\n\\nConnect의 인터셉터는 axios의 인터셉터와 비슷하지만 더 type-safe하다. 요청과 응답에 대한 모든 정보가 타입으로 보장된다.\\n\\n## 7. 에러 핸들링\\n\\nConnect RPC에서는 두 가지 에러 처리 방식이 있다:\\n\\n1. **Network/Protocol 에러**: Connect의 기본 `ConnectError` (네트워크 장애, 인증 실패 등)\\n2. **비즈니스 로직 에러**: Protobuf로 정의된 `Error` 메시지\\n\\n먼저 proto에 Error 메시지를 정의한다.\\n\\n```protobuf\\n// proto/myapp/v1/common.proto\\nmessage Error {\\n  ErrorCode code = 1;\\n  string message = 2;\\n  map\u003cstring, string\u003e details = 3;\\n}\\n\\nenum ErrorCode {\\n  ERROR_CODE_UNSPECIFIED = 0;\\n  ERROR_CODE_PROFILE_NOT_FOUND = 1;\\n  ERROR_CODE_AUTH_ERROR = 2;\\n  ERROR_CODE_INVALID_TOKEN = 3;\\n  // ...\\n}\\n```\\n\\n모든 응답은 `oneof result` 패턴을 사용한다.\\n\\n```protobuf\\nmessage VerifySignupResponse {\\n  oneof result {\\n    VerifySignupSuccess success = 1;\\n    Error error = 2;\\n  }\\n}\\n\\nmessage VerifySignupSuccess {\\n  string access_token = 1;\\n  string refresh_token = 2;\\n}\\n```\\n\\n이 패턴을 처리하기 위해 `unwrap()` 함수와 `ApplicationError` 클래스를 만든다.\\n\\n```typescript\\n// api/connectError.ts\\nimport { ConnectError } from '@connectrpc/connect';\\n\\nimport { Error as ProtoError, ErrorCode } from '@/gen/myapp/v1/common_pb';\\n\\n/**\\n * 비즈니스 로직 에러\\n * Proto에 정의된 Error 메시지를 래핑함\\n */\\nexport class ApplicationError extends Error {\\n  code: ErrorCode;\\n  details: { [key: string]: string };\\n\\n  constructor(code: ErrorCode, message: string, details: { [key: string]: string } = {}) {\\n    super(message);\\n    this.code = code;\\n    this.details = details;\\n    Object.setPrototypeOf(this, ApplicationError.prototype);\\n  }\\n\\n  static fromProto(error: ProtoError): ApplicationError {\\n    return new ApplicationError(error.code, error.message, error.details);\\n  }\\n}\\n\\n/**\\n * oneof result에서 성공값을 추출하거나 에러를 throw\\n */\\nexport function unwrap\u003cT\u003e(response: {\\n  result:\\n    | { case: 'success'; value: T }\\n    | { case: 'error'; value: ProtoError }\\n    | { case: undefined };\\n}): NonNullable\u003cT\u003e {\\n  if (response.result.case === 'error') {\\n    throw ApplicationError.fromProto(response.result.value);\\n  }\\n  if (response.result.case === 'success') {\\n    return response.result.value as NonNullable\u003cT\u003e;\\n  }\\n  throw new ApplicationError(ErrorCode.INTERNAL, 'Unknown response result');\\n}\\n\\n/**\\n * ConnectError를 ApplicationError로 변환\\n */\\nexport const handleConnectError = (error: unknown): ApplicationError =\u003e {\\n  if (error instanceof ApplicationError) {\\n    return error;\\n  }\\n\\n  if (error instanceof ConnectError) {\\n    // 네트워크 에러 등을 SYSTEM_ERROR로 매핑\\n    return new ApplicationError(ErrorCode.SYSTEM_ERROR, error.message);\\n  }\\n\\n  if (error instanceof Error) {\\n    return new ApplicationError(\\n      ErrorCode.INTERNAL,\\n      error.message || '알 수 없는 오류가 발생했습니다'\\n    );\\n  }\\n\\n  return new ApplicationError(ErrorCode.UNSPECIFIED, '알 수 없는 오류가 발생했습니다');\\n};\\n```\\n\\n### 백엔드 구현\\n\\n백엔드는 비즈니스 로직 에러를 Protobuf `Error` 메시지로 만든다. 이 방식을 사용하면 에러 코드가 proto enum으로 정의되어 백엔드-프론트엔드 간 타입 일치가 보장된다.\\n\\n```go\\n// internal/response/errors.go\\nfunc NewConnectError(code domain.ErrorCode, err error) *connect.Error {\\n  connectErr := connect.NewError(toConnectCode(code), err)\\n\\n  // Protobuf Error 메시지 생성\\n  protoErr := \u0026duologuev1.Error{\\n    Code:    domain.ToProtoErrorCode(code),\\n    Message: err.Error(),\\n    Details: make(map[string]string),\\n  }\\n\\n  // Error를 Connect error detail로 추가\\n  if detail, detailErr := connect.NewErrorDetail(protoErr); detailErr == nil {\\n    connectErr.AddDetail(detail)\\n  }\\n\\n  return connectErr\\n}\\n```\\n\\n### 인터셉터에서 에러 코드별 처리\\n\\n인터셉터에서 특정 에러 코드에 대한 공통 처리를 할 수 있다.\\n\\n```typescript\\n// api/interceptors.ts\\nexport const createAuthInterceptor = (): Interceptor =\u003e next =\u003e async req =\u003e {\\n  const token = useAuthStore.getState().accessToken;\\n  if (token) {\\n    req.header.set('Authorization', `Bearer ${token}`);\\n  }\\n\\n  try {\\n    return await next(req);\\n  } catch (error) {\\n    if (error instanceof ApplicationError) {\\n      // 프로필 없음 → 로그아웃 처리\\n      if (error.code === ErrorCode.PROFILE_NOT_FOUND) {\\n        useAuthStore.getState().clearAuth();\\n        router.replace('/');\\n        throw error;\\n      }\\n\\n      // 인증 에러 → 토큰 갱신 시도\\n      if (\\n        error.code === ErrorCode.AUTH_ERROR ||\\n        error.code === ErrorCode.AUTH_REQUIRED ||\\n        error.code === ErrorCode.INVALID_TOKEN\\n      ) {\\n        const newToken = await tokenRefreshManager.refresh();\\n        req.header.set('Authorization', `Bearer ${newToken}`);\\n        return await next(req); // 재시도\\n      }\\n    }\\n\\n    throw error;\\n  }\\n};\\n```\\n\\n이 패턴을 사용하면:\\n\\n1. **타입 안전한 에러 처리**: ErrorCode enum으로 가능한 에러를 컴파일 타임에 알 수 있음\\n2. **중앙화된 에러 처리**: 인터셉터에서 공통 에러 로직 처리\\n3. **명시적인 에러 흐름**: oneof를 통해 성공/실패가 proto 레벨에서 명확히 구분됨\\n\\n## 8. API 레이어 마이그레이션\\n\\n이제 기존 axios 기반 API를 Connect로 교체한다.\\n\\n### Before (axios)\\n\\n```typescript\\n// api/auth.ts (before)\\nimport { apiClient } from './client';\\n\\ninterface VerifySignupRequest {\\n  email: string;\\n  code: string;\\n}\\n\\ninterface TokenResponse {\\n  access_token: string;\\n  refresh_token: string;\\n}\\n\\nexport const authApi = {\\n  verifySignup: async (email: string, code: string): Promise\u003cTokenResponse\u003e =\u003e {\\n    const response = await apiClient.post\u003cTokenResponse\u003e('/auth/verify-signup', {\\n      email,\\n      code,\\n    });\\n    return response.data;\\n  },\\n};\\n```\\n\\n### After (Connect)\\n\\n```typescript\\n// api/auth.ts (after)\\nimport { create } from '@bufbuild/protobuf';\\n\\nimport { VerifySignupRequestSchema } from '@/gen/myapp/v1/auth_pb';\\n\\nimport { handleConnectError } from './connectError';\\nimport { authClient } from './transport';\\n\\ninterface TokenResponse {\\n  accessToken: string;\\n  refreshToken: string;\\n}\\n\\nexport const authApi = {\\n  verifySignup: async (email: string, code: string): Promise\u003cTokenResponse\u003e =\u003e {\\n    try {\\n      const request = create(VerifySignupRequestSchema, { email, code });\\n      const response = await authClient.verifySignup(request);\\n      const result = unwrap(response); // oneof result 처리\\n      return {\\n        accessToken: result.accessToken,\\n        refreshToken: result.refreshToken,\\n      };\\n    } catch (error) {\\n      throw handleConnectError(error);\\n    }\\n  },\\n};\\n```\\n\\n변경된 점:\\n\\n1. **타입을 수동으로 정의하지 않는다** - proto에서 자동 생성됨\\n2. **URL 경로를 하드코딩하지 않는다** - 서비스 정의에 포함됨\\n3. **create()로 요청 메시지를 생성한다** - 타입 안전성 보장\\n\\n### Profile API 예시\\n\\n```typescript\\n// api/profile.ts\\nimport { create } from '@bufbuild/protobuf';\\n\\nimport { GetMyProfileRequestSchema, UpdateMyProfileRequestSchema } from '@/gen/myapp/v1/profile_pb';\\n\\nimport { handleConnectError } from './connectError';\\nimport { profileClient } from './transport';\\n\\nexport const profileApi = {\\n  getMe: async (): Promise\u003cProfileMe\u003e =\u003e {\\n    try {\\n      const request = create(GetMyProfileRequestSchema, {});\\n      const response = await profileClient.getMyProfile(request);\\n      const result = unwrap(response); // oneof result 처리\\n\\n      return mapProfile(result.profile);\\n    } catch (error) {\\n      throw handleConnectError(error);\\n    }\\n  },\\n\\n  updateMe: async (data: UpdateProfileData): Promise\u003cProfileMe\u003e =\u003e {\\n    try {\\n      const request = create(UpdateMyProfileRequestSchema, {\\n        nickname: data.nickname,\\n        gender: data.gender,\\n        region: data.region,\\n        shortBio: data.shortBio,\\n        profileImageUrl: data.profileImageUrl,\\n        interestIds: data.interestIds?.map(id =\u003e BigInt(id)) ?? [],\\n      });\\n\\n      const response = await profileClient.updateMyProfile(request);\\n      const result = unwrap(response); // oneof result 처리\\n\\n      return mapProfile(result.profile);\\n    } catch (error) {\\n      throw handleConnectError(error);\\n    }\\n  },\\n};\\n```\\n\\n## 9. React Query 훅은 그대로\\n\\n[React Query](https://tanstack.com/query/latest) 훅은 API 함수만 호출하므로 수정할 필요가 없다.\\n\\n```typescript\\n// queries/useMutationAuth.ts\\nexport const useVerifySignup = () =\u003e {\\n  return useMutation({\\n    mutationFn: ({ email, code }: VerifySignupParams) =\u003e authApi.verifySignup(email, code),\\n    onSuccess: data =\u003e {\\n      setTokens(data.accessToken, data.refreshToken);\\n    },\\n  });\\n};\\n```\\n\\nAPI 레이어만 교체했으므로 컴포넌트 코드는 전혀 수정하지 않아도 된다.\\n\\n## 10. axios 제거\\n\\n마이그레이션이 완료되면 axios를 제거한다.\\n\\n```bash\\nyarn remove axios\\n```\\n\\n기존에 axios를 사용하던 파일들도 삭제한다:\\n\\n```bash\\nrm api/client.ts  # axios 클라이언트\\n```\\n\\n## 결과\\n\\n### 타입 안전성 확보\\n\\n이제 백엔드가 API를 변경하면 프론트엔드가 **컴파일 타임에** 에러가 발생한다.\\n\\n```typescript\\n// proto에서 nickname 필드가 제거되면\\nconst profile = await profileApi.getMe();\\nconsole.log(profile.nickname); // ❌ TypeScript 에러: 'nickname' does not exist\\n```\\n\\n### 개발 경험 개선\\n\\n1. **자동 완성이 정확하다**: proto에 정의된 필드만 자동 완성됨\\n2. **리팩토링이 안전하다**: 필드명을 바꾸면 사용하는 모든 곳에서 에러 발생\\n3. **문서가 필요 없다**: proto 파일이 곧 API 명세서\\n\\n### 유지보수 비용 감소\\n\\n- 타입 정의를 수동으로 관리할 필요 없음\\n- snake_case ↔ camelCase 변환 코드 불필요\\n- API 변경 시 영향받는 코드를 TypeScript가 알려줌\\n\\n## Binary vs JSON\\n\\nConnect RPC는 binary(Protobuf)와 JSON 두 가지 포맷을 지원한다. `createConnectTransport`는 기본적으로 binary 포맷을 사용하므로, 별도 설정 없이도 binary의 이점을 누릴 수 있다.\\n\\n- **Binary (기본값)**: 더 작은 페이로드, 더 빠른 직렬화/역직렬화\\n- **JSON**: 디버깅이 쉬움 (네트워크 탭에서 내용 확인 가능)\\n\\nProto 스키마의 타입 안전성을 유지하면서 실제 통신 데이터 포맷은 선택할 수 있다는 것이 Connect RPC의 큰 장점이다. 개발 환경에서 디버깅이 필요하다면 JSON으로, 프로덕션에서는 Binary로 전환하는 것도 가능하다.\\n\\n```typescript\\nconst transport = createConnectTransport({\\n  baseUrl: API_URL,\\n  useBinaryFormat: false, // JSON 사용 (디버깅 시 편리)\\n  // useBinaryFormat을 생략하면 기본값인 true(binary)가 적용됨\\n});\\n```\\n\\n## 주의사항\\n\\n### 1. Metro 설정 필수\\n\\n`unstable_enablePackageExports`를 활성화하지 않으면 런타임 에러가 발생한다. 이 설정을 빠뜨리면 앱이 제대로 실행되지 않는다.\\n\\n### 2. Streaming은 미지원\\n\\nConnect RPC는 [Unary RPC](https://grpc.io/docs/what-is-grpc/core-concepts/#unary-rpc)만 지원한다. [Server Streaming](https://grpc.io/docs/what-is-grpc/core-concepts/#server-streaming-rpc)이나 [Bidirectional Streaming](https://grpc.io/docs/what-is-grpc/core-concepts/#bidirectional-streaming-rpc)은 React Native에서 작동하지 않는다.\\n\\n### 3. 코드 생성 타이밍\\n\\nproto 파일이 변경되면 `yarn generate`를 다시 실행해야 한다. submodule을 업데이트할 때마다 실행하는 것을 잊지 말자.\\n\\n```bash\\n# proto submodule 업데이트 후\\ngit submodule update --remote proto\\nyarn generate\\n```\\n\\nproto 파일은 Protobuf의 네이밍 규칙에 따라 snake_case를 사용하지만, Connect는 코드 생성 시 자동으로 TypeScript의 camelCase로 변환해준다.\\n\\n## 마무리\\n\\nREST API에서 Connect RPC로 마이그레이션하면서 가장 만족스러운 점은 **타입 안전성**이다. 백엔드가 API를 변경하면 프론트엔드가 런타임이 아닌 컴파일 타임에 깨지므로, 배포 전에 문제를 발견할 수 있다.\\n\\n수동으로 타입을 정의하던 시간을 아낄 수 있고, proto 파일만 보면 API 명세를 정확히 알 수 있어 문서를 별도로 관리할 필요도 없어졌다.\\n\\n백엔드와 프론트엔드가 상호완결성을 가지는 서비스 프로덕트라면 gRPC 도입을 고려 해보는 것도 나쁘지 않은 것 같다.\\n\"}}]]}]],null],\"segment\":\"__PAGE__?{\\\"tag\\\":\\\"gRPC\\\"}\"},\"styles\":[]}],\"segment\":[\"tag\",\"gRPC\",\"d\"]},\"styles\":[]}],\"segment\":\"tags\"},\"styles\":[]}],\"params\":{}}],null]}]]\n"])</script><script>self.__next_f.push([1,"7:[[[\"$\",\"meta\",null,{\"charSet\":\"utf-8\"}],null,null,null,null,null,null,null,null,null,null,[\"$\",\"meta\",null,{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],null,null,null,null,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,null,null,null,null]\n4:[[[\"$\",\"meta\",null,{\"charSet\":\"utf-8\"}],null,null,null,null,null,null,null,null,null,null,[\"$\",\"meta\",null,{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],null,null,null,nu"])</script><script>self.__next_f.push([1,"ll,null,null,null,null,null,null,[]],[null,null,null,null],null,null,[null,null,null,null,null],null,null,null,null,[null,[[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/icon.svg?43070ac23468c58b\",\"type\":\"image/svg+xml\",\"sizes\":\"32x32\"}]],[],null]]\n"])</script></body></html>